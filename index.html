<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/source/images/favicon-32x32-me.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/source/images/favicon-16x16-me.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>
<meta name="description" content="focus creates reality">
<meta property="og:type" content="website">
<meta property="og:title" content="Meng&#39;s Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Meng&#39;s Blog">
<meta property="og:description" content="focus creates reality">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Meng Zhili">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>
<title>Meng's Blog</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Meng's Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">To be rock not to roll</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Meng Zhili"
      src="/images/blog-logo.jpg">
  <p class="site-author-name" itemprop="name">Meng Zhili</p>
  <div class="site-description" itemprop="description">focus creates reality</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhilimeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhilimeng" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://mengzhili_whu@163.com/" title="E-Mail → https:&#x2F;&#x2F;mengzhili_whu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/18/distance-between-two-lines/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/18/distance-between-two-lines/" class="post-title-link" itemprop="url">直线线段之间的最小距离求解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-18 23:57:20" itemprop="dateCreated datePublished" datetime="2021-04-18T23:57:20+00:00">2021-04-18</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Geometry/" itemprop="url" rel="index"><span itemprop="name">Geometry</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>我们经常需要计算两个几何物体之间的最小距离，任意两个几何物体之间的欧式距离定义为它们之间任意两点的最小距离。对于两个几何体 <span class="math inline">\(\mathbf{G_1}\)</span> 和 <span class="math inline">\(\mathbf{G_2}\)</span>，它们之间的距离定义为： <span class="math display">\[d(\mathbf{G_1}, \mathbf{G_2}) = \min_{P \in \mathbf{G_1}, Q \in \mathbf{G_2}} d(P, Q) \]</span></p>
<p>求解两条直线之间的最短距离就是寻找两点，<span class="math inline">\(P_C \in \mathbf{G_1}\)</span>， <span class="math inline">\(Q_c \in \mathbf{G_2}\)</span>之间的距离最小，这时 <span class="math inline">\(d(\mathbf{G_1},\mathbf{G_2}) = d(P_C, Q_C)\)</span>。</p>
<h2 id="直线间的距离">直线间的距离</h2>
<p>假设两条直线 <span class="math display">\[
\begin{array}{ll}
\mathbf{L_1}: P(s) = P_0 + s(P_1-P_0)=P_0 + s \mathbf{u} \\
\mathbf{L_2}: Q(s) = Q_0 + t(Q_1-Q_0)=Q_0 + t \mathbf{v}    
\end{array}
\]</span><br />
设 <span class="math inline">\(\mathbf{w}(s,t) = P(s)-Q(t)\)</span>是两条直线上点之间的向量。我们希望找到对于所有的<span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>，向量<span class="math inline">\(\mathbf{w}(s,t)\)</span>都有最小的长度。假设<span class="math inline">\(\mathbf{L_1}\)</span>和<span class="math inline">\(\mathbf{L_2}\)</span> 点<span class="math inline">\(P_c = P(s_C)\)</span> 和 <span class="math inline">\(Q_C=Q(t_C)\)</span>时最近，此时<span class="math inline">\(\mathbf{w}(s_C,t_C)\)</span>是<span class="math inline">\(\mathbf{w}(s,t)\)</span> 的最小值。如果<span class="math inline">\(\mathbf{L_1}\)</span> 和 <span class="math inline">\(\mathbf{L_2}\)</span>彼此不平行也不相交，这时<span class="math inline">\(P_CQ_C\)</span>同时垂直于这两条直线,也就是向量<span class="math inline">\(\mathbf{w_C} = w(s_C, t_C)\)</span>垂直于两条线的方向向量<span class="math inline">\(\mathbf u\)</span> 和<span class="math inline">\(\mathbf v\)</span>, 等价于满足两个方程： <span class="math inline">\(\mathbf u * \mathbf w_C = 0\)</span>和<span class="math inline">\(\mathbf v * \mathbf w_C = 0\)</span>。</p>
<p><img src="/2021/04/18/distance-between-two-lines/line_distance.png" class="" title="line distance"></p>
<p>向量<span class="math inline">\(\mathbf W_C = P(S_C)-Q(t_C)=\mathbf W_0 + s_C \mathbf{u} - t_C \mathbf{v}\)</span>，这里<span class="math inline">\(\mathbf{w_0} = P_0 - Q_0\)</span>，将其代入上述两个方程可以得到： <span class="math display">\[
\begin{array}{ll}
（\mathbf{u} \cdot \mathbf{u})s_C - (\mathbf{u} \cdot \mathbf{v})t_C = -\mathbf{u} \cdot \mathbf{w_0} \\
（\mathbf{v} \cdot \mathbf{u})s_C - (\mathbf{v} \cdot \mathbf{v})t_C = -\mathbf{v} \cdot \mathbf{w_0}   
\end{array}
\]</span></p>
<p>让<span class="math inline">\(a=\mathbf u \cdot \mathbf u, b = \mathbf u \cdot \mathbf v, c = \mathbf v \cdot \mathbf v,d= \mathbf u \cdot \mathbf w_0\)</span>，可以解得：<br />
<span class="math display">\[
s_C = \frac{be-cd}{ac-b^2}
\]</span> <span class="math display">\[
t_C = \frac{ae-bd}{ac-b^2}
\]</span> 注意分母<span class="math inline">\(ac-b^2 = {|\mathbf u|}^2 {|\mathbf v|}^2 - (|\mathbf{u}||\mathbf{v}|\cos \theta)^2 = (|\mathbf u||\mathbf v| \sin \theta)^2 \geq 0\)</span>永远非负。当为零时，两条直线平行，其之间的距离是常量。可以让<span class="math inline">\(s_C=0\)</span>,得到<span class="math inline">\(t_C= d/b=e/c\)</span>。</p>
<p>求得<span class="math inline">\(s_C\)</span>和<span class="math inline">\(t_C\)</span>后，可以计算得到直线<span class="math inline">\(\mathbf L_1\)</span>和直线<span class="math inline">\(\mathbf L_2\)</span>上的两点<span class="math inline">\(P_C\)</span>和<span class="math inline">\(Q_C\)</span>，两点间的距离为： <span class="math display">\[
d(\mathbf L_1, \mathbf L_2) = |P(s_C)-Q(t_C)|=|(P_0-Q_0)+\frac{(be-cd)\mathbf u - (ae-bd)\mathbf v}{ac-b^2}|
\]</span></p>
<h2 id="线段和射线间的距离">线段和射线间的距离</h2>
<p>线段和射线间的最短距离点必须在线段或者射线上。用<span class="math inline">\(P_0\)</span>,<span class="math inline">\(P_1\)</span>两点来表示线段<span class="math inline">\(\mathbf S_1 = [P_0,P_1]\)</span>，<span class="math inline">\(P(s)=P_0+s(P_1-P_0)=P_0+s\mathbf u\)</span> 这里 <span class="math inline">\(0 \leq s \leq 1\)</span>。射线<span class="math inline">\(\mathbf R_1\)</span>也可以由<span class="math inline">\(P(s)\)</span>表示，这里<span class="math inline">\(s\geq0\)</span>，类似地，线段<span class="math inline">\(\mathbf S_2=[Q_0,Q_1]\)</span>可以由<span class="math inline">\(\mathbf Q(t)\)</span>表示 <span class="math inline">\(0 \leq t \leq 1\)</span>。<br />
求解线段或者射线之间的距离的第一步是先求解它们所在直线之间的距离。所以，我们首先对<span class="math inline">\(\mathbf L_1\)</span> 和 <span class="math inline">\(\mathbf L_2\)</span>计算<span class="math inline">\(s_C\)</span>和<span class="math inline">\(t_C\)</span>，如果它们都在线段或者射线上，则它们就是距离最近的点。否则，我们需要找到新的点使得<span class="math inline">\(\mathbf w(s,t) = P(s) - Q(t)\)</span>最小，等价于最小化<span class="math inline">\({|\mathbf w|}^2 = \mathbf w \cdot \mathbf w = (\mathbf w_0 + s \mathbf u - t \mathbf v) \cdot (\mathbf w_0 + s \mathbf u - t \mathbf v)\)</span>，这是一个<span class="math inline">\(s\)</span>和<span class="math inline">\(t\)</span>的二次函数。实际上，<span class="math inline">\({|\mathbf w|}^2\)</span>定义了在<span class="math inline">\((s,t)\)</span>平面上的抛物面，最低点在<span class="math inline">\(\mathbf C = (s_C, t_C)\)</span>，在<span class="math inline">\((s,t)\)</span>平面上从<span class="math inline">\(C\)</span>开始向任何方向都是严格递增的，但是当涉及到线段或者射线时，需要最小化<span class="math inline">\((s，t)\)</span>平面上的一个子区域<span class="math inline">\(\mathbf G\)</span>，全局最低点有可能在<span class="math inline">\(\mathbf G\)</span>外部。但是，这种情况下，最小值都会出现在<span class="math inline">\(\mathbf G\)</span>的边界上，特殊情况下，<span class="math inline">\(\mathbf G\)</span>边界的部分对<span class="math inline">\(C\)</span>是可见的。也就是说有一个从<span class="math inline">\(C\)</span>到边界点的直线在<span class="math inline">\(\mathbf G\)</span>的外部，因此我们可以说<span class="math inline">\(C\)</span>可以看见<span class="math inline">\(\mathbf G\)</span>边界上的点。</p>
<p>假设我们想得到两个线段<span class="math inline">\(\mathbf S_1\)</span>和<span class="math inline">\(\mathbf S_2\)</span>之间的最小距离。我们有<span class="math inline">\(\mathbf G ={(s,t)|0 \leq s \leq 1 and 0 \leq t \leq 1} = [0,1]\times[0,1]\)</span> 是一个单位四边形，正方形的四个边为<span class="math inline">\(s=0,s=1,t=0,t=1\)</span>。 如果<span class="math inline">\(\mathbf C = (s_C, t_C)\)</span>在<span class="math inline">\(\mathbf G\)</span>外，则它最多可以看到<span class="math inline">\(\mathbf G\)</span>的两条边。 如果<span class="math inline">\(s_C &lt; 0\)</span>，<span class="math inline">\(\mathbf C\)</span>可以看到边<span class="math inline">\(s=0\)</span>；如果<span class="math inline">\(s_C &gt; 1\)</span>，<span class="math inline">\(\mathbf C\)</span>可以看到边<span class="math inline">\(s=1\)</span>；<span class="math inline">\(t_C\)</span>类似。很明显，如果<span class="math inline">\(\mathbf C\)</span>不在 <span class="math inline">\(\mathbf G\)</span>内，则最小一个，最多两个这些不等式成立，它们决定了最小化<span class="math inline">\({|\mathbf w|}^2\)</span>时<span class="math inline">\(\mathbf G\)</span>的候选边。</p>
<img src="/2021/04/18/distance-between-two-lines/segment_distance.png" class="" title="seg distance">
<p>对于每个候选边，我们计算最小值在边上，在内部或者是终点。考虑<span class="math inline">\(s=0\)</span>的边，这时<span class="math inline">\({|\mathbf w|}^2 = (\mathbf w_0 - t \mathbf v)\cdot(\mathbf w_0 - t \mathbf v)\)</span>。对<span class="math inline">\(t\)</span>求导得到： <span class="math display">\[
0 = \frac{d}{dt} {|\mathbf w|}^2 = -2\mathbf v \cdot (\mathbf w_0 - t\mathbf v)
\]</span> 求得 <span class="math display">\[
t_0 = \frac{\mathbf v \cdot \mathbf w_0}{\mathbf v \cdot \mathbf v}
\]</span> 如果<span class="math inline">\(0\leq t_0 \leq 1\)</span>,则<span class="math inline">\(P(0)\)</span> 和 <span class="math inline">\(Q(t_0)\)</span>就是两个线段上的最邻近点。但是，如果<span class="math inline">\(t_0\)</span>在边外边，则边的终点,(0,0)或者(0,1)是距离最小点；另外，我们需要进一步检查第二个可见边以防真正的最小值在它上边。</p>
<h2 id="碰撞距离">碰撞距离</h2>
<p><code>Closet Point of Approach</code>指的是两个动态移动物体达到它们最接近距离时的位置。考虑两个该时间<span class="math inline">\(t\)</span>动态变化的点<span class="math inline">\(P(t)\)</span>和<span class="math inline">\(Q(t)\)</span>。令<span class="math inline">\(t=0\)</span>时刻的位置为<span class="math inline">\(P_0\)</span>和<span class="math inline">\(Q_0\)</span>；单位时间的速度向量为<span class="math inline">\(\mathbf u\)</span> 和 <span class="math inline">\(\mathbf v\)</span>。两点的运动方程为<span class="math inline">\(P(t)=P_0+t\mathbf u\)</span>和 <span class="math inline">\(Q(t)=Q_0+t\mathbf v\)</span>，和直线的参数方程类似。但是这两个方程有共同的参数<span class="math inline">\(t\)</span>。所以，在<span class="math inline">\(t\)</span>时刻，两点的距离<span class="math inline">\(d(t)=|P(t)-Q(t)|=|\mathbf w(t)|\)</span>,这里<span class="math inline">\(\mathbf w(t)=\mathbf w_0 + t(\mathbf u - t \mathbf v)\)</span>， <span class="math inline">\(\mathbf w_0 = P_0 - Q_0\)</span>。</p>
<img src="/2021/04/18/distance-between-two-lines/cpa_distance.png" class="" title="cpa distance">
<p>由于<span class="math inline">\(d(t)\)</span>最小等价于<span class="math inline">\(D(t)=d(t)^2\)</span>最小，可以计算得到： <span class="math display">\[
D(t)=\mathbf w(t) \cdot \mathbf w(t)=(\mathbf u - \mathbf v)\cdot (\mathbf u -\mathbf v)t^2 + 2\mathbf w_0 \cdot(\mathbf u - \mathbf v)t + \mathbf w_0 \cdot \mathbf w_0  
\]</span> 对<span class="math inline">\(t\)</span>求导得到： <span class="math display">\[
0=\frac{d}{dt}D(t)=2t[(\mathbf u - \mathbf v)\cdot (\mathbf u - \mathbf v)]+2 \mathbf w_0 \cdot(\mathbf u - \mathbf v)
\]</span></p>
<p>求解得到： <span class="math display">\[
t_{CPA}=\frac{-\mathbf w_0 \cdot (\mathbf u - \mathbf v)}{\vert \mathbf u - \mathbf v \vert ^2}
\]</span> 如果 <span class="math inline">\(|\mathbf u - \mathbf v| = 0\)</span>， 则这两个点以相同速度朝相同方向运动，将永远保持相同距离，所以我们可以用<span class="math inline">\(t_{CPA}=0\)</span>。我们可以计算得到距离： <span class="math display">\[
d_{CPA}(P(t),Q(t))=|P(t_{CPA})-Q(t_{CPA})|
\]</span> 注意，当<span class="math inline">\(t_{CPA} &lt;0\)</span>时，表示CPA已经在过去发生，两个跟踪点随时间将距离越来越远。</p>
<h2 id="代码实现">代码实现</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Copyright 2001, 2012, 2021 Dan Sunday</span><br><span class="line">&#x2F;&#x2F; This code may be freely used and modified for any purpose</span><br><span class="line">&#x2F;&#x2F; providing that this copyright notice is included with it.</span><br><span class="line">&#x2F;&#x2F; There is no warranty for this code, and the author of it cannot</span><br><span class="line">&#x2F;&#x2F; be held liable for any real or imagined damage from its use.</span><br><span class="line">&#x2F;&#x2F; Users of this code must verify correctness for their application.</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; Assume that classes are already given for the objects:</span><br><span class="line">&#x2F;&#x2F;    Point and Vector with</span><br><span class="line">&#x2F;&#x2F;        coordinates &#123;float x, y, z;&#125;</span><br><span class="line">&#x2F;&#x2F;        operators for:</span><br><span class="line">&#x2F;&#x2F;            Point   &#x3D; Point ± Vector</span><br><span class="line">&#x2F;&#x2F;            Vector &#x3D;  Point - Point</span><br><span class="line">&#x2F;&#x2F;            Vector &#x3D;  Vector ± Vector</span><br><span class="line">&#x2F;&#x2F;            Vector &#x3D;  Scalar * Vector</span><br><span class="line">&#x2F;&#x2F;    Line and Segment with defining points &#123;Point  P0, P1;&#125;</span><br><span class="line">&#x2F;&#x2F;    Track with initial position and velocity vector</span><br><span class="line">&#x2F;&#x2F;            &#123;Point P0;  Vector v;&#125;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#define SMALL_NUM   0.00000001 &#x2F;&#x2F; anything that avoids division overflow</span><br><span class="line">&#x2F;&#x2F; dot product (3D) which allows vector operations in arguments</span><br><span class="line">#define dot(u,v)   ((u).x * (v).x + (u).y * (v).y + (u).z * (v).z)</span><br><span class="line">#define norm(v)    sqrt(dot(v,v))  &#x2F;&#x2F; norm &#x3D; length of  vector</span><br><span class="line">#define d(u,v)     norm(u-v)        &#x2F;&#x2F; distance &#x3D; norm of difference</span><br><span class="line">#define abs(x)     ((x) &gt;&#x3D; 0 ? (x) : -(x))   &#x2F;&#x2F;  absolute value</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; dist3D_Line_to_Line(): get the 3D minimum distance between 2 lines</span><br><span class="line">&#x2F;&#x2F;    Input:  two 3D lines L1 and L2</span><br><span class="line">&#x2F;&#x2F;    Return: the shortest distance between L1 and L2</span><br><span class="line">float</span><br><span class="line">dist3D_Line_to_Line( Line L1, Line L2)</span><br><span class="line">&#123;</span><br><span class="line">    Vector   u &#x3D; L1.P1 - L1.P0;</span><br><span class="line">    Vector   v &#x3D; L2.P1 - L2.P0;</span><br><span class="line">    Vector   w &#x3D; L1.P0 - L2.P0;</span><br><span class="line">    float    a &#x3D; dot(u,u);         &#x2F;&#x2F; always &gt;&#x3D; 0</span><br><span class="line">    float    b &#x3D; dot(u,v);</span><br><span class="line">    float    c &#x3D; dot(v,v);         &#x2F;&#x2F; always &gt;&#x3D; 0</span><br><span class="line">    float    d &#x3D; dot(u,w);</span><br><span class="line">    float    e &#x3D; dot(v,w);</span><br><span class="line">    float    D &#x3D; a*c - b*b;        &#x2F;&#x2F; always &gt;&#x3D; 0</span><br><span class="line">    float    sc, tc;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; compute the line parameters of the two closest points</span><br><span class="line">    if (D &lt; SMALL_NUM) &#123;          &#x2F;&#x2F; the lines are almost parallel</span><br><span class="line">        sc &#x3D; 0.0;</span><br><span class="line">        tc &#x3D; (b&gt;c ? d&#x2F;b : e&#x2F;c);    &#x2F;&#x2F; use the largest denominator</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        sc &#x3D; (b*e - c*d) &#x2F; D;</span><br><span class="line">        tc &#x3D; (a*e - b*d) &#x2F; D;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; get the difference of the two closest points</span><br><span class="line">    Vector   dP &#x3D; w + (sc * u) - (tc * v);  &#x2F;&#x2F; &#x3D;  L1(sc) - L2(tc)</span><br><span class="line"></span><br><span class="line">    return norm(dP);   &#x2F;&#x2F; return the closest distance</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; dist3D_Segment_to_Segment(): get the 3D minimum distance between 2 segments</span><br><span class="line">&#x2F;&#x2F;    Input:  two 3D line segments S1 and S2</span><br><span class="line">&#x2F;&#x2F;    Return: the shortest distance between S1 and S2</span><br><span class="line">float</span><br><span class="line">dist3D_Segment_to_Segment( Segment S1, Segment S2)</span><br><span class="line">&#123;</span><br><span class="line">    Vector   u &#x3D; S1.P1 - S1.P0;</span><br><span class="line">    Vector   v &#x3D; S2.P1 - S2.P0;</span><br><span class="line">    Vector   w &#x3D; S1.P0 - S2.P0;</span><br><span class="line">    float    a &#x3D; dot(u,u);         &#x2F;&#x2F; always &gt;&#x3D; 0</span><br><span class="line">    float    b &#x3D; dot(u,v);</span><br><span class="line">    float    c &#x3D; dot(v,v);         &#x2F;&#x2F; always &gt;&#x3D; 0</span><br><span class="line">    float    d &#x3D; dot(u,w);</span><br><span class="line">    float    e &#x3D; dot(v,w);</span><br><span class="line">    float    D &#x3D; a*c - b*b;        &#x2F;&#x2F; always &gt;&#x3D; 0</span><br><span class="line">    float    sc, sN, sD &#x3D; D;       &#x2F;&#x2F; sc &#x3D; sN &#x2F; sD, default sD &#x3D; D &gt;&#x3D; 0</span><br><span class="line">    float    tc, tN, tD &#x3D; D;       &#x2F;&#x2F; tc &#x3D; tN &#x2F; tD, default tD &#x3D; D &gt;&#x3D; 0</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; compute the line parameters of the two closest points</span><br><span class="line">    if (D &lt; SMALL_NUM) &#123; &#x2F;&#x2F; the lines are almost parallel</span><br><span class="line">        sN &#x3D; 0.0;         &#x2F;&#x2F; force using point P0 on segment S1</span><br><span class="line">        sD &#x3D; 1.0;         &#x2F;&#x2F; to prevent possible division by 0.0 later</span><br><span class="line">        tN &#x3D; e;</span><br><span class="line">        tD &#x3D; c;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;                 &#x2F;&#x2F; get the closest points on the infinite lines</span><br><span class="line">        sN &#x3D; (b*e - c*d);</span><br><span class="line">        tN &#x3D; (a*e - b*d);</span><br><span class="line">        if (sN &lt; 0.0) &#123;        &#x2F;&#x2F; sc &lt; 0 &#x3D;&gt; the s&#x3D;0 edge is visible</span><br><span class="line">            sN &#x3D; 0.0;</span><br><span class="line">            tN &#x3D; e;</span><br><span class="line">            tD &#x3D; c;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (sN &gt; sD) &#123;  &#x2F;&#x2F; sc &gt; 1  &#x3D;&gt; the s&#x3D;1 edge is visible</span><br><span class="line">            sN &#x3D; sD;</span><br><span class="line">            tN &#x3D; e + b;</span><br><span class="line">            tD &#x3D; c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (tN &lt; 0.0) &#123;            &#x2F;&#x2F; tc &lt; 0 &#x3D;&gt; the t&#x3D;0 edge is visible</span><br><span class="line">        tN &#x3D; 0.0;</span><br><span class="line">        &#x2F;&#x2F; recompute sc for this edge</span><br><span class="line">        if (-d &lt; 0.0)</span><br><span class="line">            sN &#x3D; 0.0;</span><br><span class="line">        else if (-d &gt; a)</span><br><span class="line">            sN &#x3D; sD;</span><br><span class="line">        else &#123;</span><br><span class="line">            sN &#x3D; -d;</span><br><span class="line">            sD &#x3D; a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (tN &gt; tD) &#123;      &#x2F;&#x2F; tc &gt; 1  &#x3D;&gt; the t&#x3D;1 edge is visible</span><br><span class="line">        tN &#x3D; tD;</span><br><span class="line">        &#x2F;&#x2F; recompute sc for this edge</span><br><span class="line">        if ((-d + b) &lt; 0.0)</span><br><span class="line">            sN &#x3D; 0;</span><br><span class="line">        else if ((-d + b) &gt; a)</span><br><span class="line">            sN &#x3D; sD;</span><br><span class="line">        else &#123;</span><br><span class="line">            sN &#x3D; (-d +  b);</span><br><span class="line">            sD &#x3D; a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; finally do the division to get sc and tc</span><br><span class="line">    sc &#x3D; (abs(sN) &lt; SMALL_NUM ? 0.0 : sN &#x2F; sD);</span><br><span class="line">    tc &#x3D; (abs(tN) &lt; SMALL_NUM ? 0.0 : tN &#x2F; tD);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; get the difference of the two closest points</span><br><span class="line">    Vector   dP &#x3D; w + (sc * u) - (tc * v);  &#x2F;&#x2F; &#x3D;  S1(sc) - S2(tc)</span><br><span class="line"></span><br><span class="line">    return norm(dP);   &#x2F;&#x2F; return the closest distance</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cpa_time(): compute the time of CPA for two tracks</span><br><span class="line">&#x2F;&#x2F;    Input:  two tracks Tr1 and Tr2</span><br><span class="line">&#x2F;&#x2F;    Return: the time at which the two tracks are closest</span><br><span class="line">float</span><br><span class="line">cpa_time( Track Tr1, Track Tr2 )</span><br><span class="line">&#123;</span><br><span class="line">    Vector   dv &#x3D; Tr1.v - Tr2.v;</span><br><span class="line"></span><br><span class="line">    float    dv2 &#x3D; dot(dv,dv);</span><br><span class="line">    if (dv2 &lt; SMALL_NUM)      &#x2F;&#x2F; the  tracks are almost parallel</span><br><span class="line">        return 0.0;             &#x2F;&#x2F; any time is ok.  Use time 0.</span><br><span class="line"></span><br><span class="line">    Vector   w0 &#x3D; Tr1.P0 - Tr2.P0;</span><br><span class="line">    float    cpatime &#x3D; -dot(w0,dv) &#x2F; dv2;</span><br><span class="line"></span><br><span class="line">    return cpatime;             &#x2F;&#x2F; time of CPA</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cpa_distance(): compute the distance at CPA for two tracks</span><br><span class="line">&#x2F;&#x2F;    Input:  two tracks Tr1 and Tr2</span><br><span class="line">&#x2F;&#x2F;    Return: the distance for which the two tracks are closest</span><br><span class="line">float</span><br><span class="line">cpa_distance( Track Tr1, Track Tr2 )</span><br><span class="line">&#123;</span><br><span class="line">    float    ctime &#x3D; cpa_time( Tr1, Tr2);</span><br><span class="line">    Point    P1 &#x3D; Tr1.P0 + (ctime * Tr1.v);</span><br><span class="line">    Point    P2 &#x3D; Tr2.P0 + (ctime * Tr2.v);</span><br><span class="line"></span><br><span class="line">    return d(P1,P2);            &#x2F;&#x2F; distance at CPA</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/22/cpp-concurrency-synchronizing-concurrent-operations/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/22/cpp-concurrency-synchronizing-concurrent-operations/" class="post-title-link" itemprop="url">cpp-concurrency-synchronizing-concurrent-operations</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-22 17:03:28" itemprop="dateCreated datePublished" datetime="2020-09-22T17:03:28+00:00">2020-09-22</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="等待一个事件或者其他条件">等待一个事件或者其他条件</h2>
<p>有些时候我们不仅是需要保护数据同时需要在线程间同步操作，比如希望一个线程等待一个特定的事件发生或者一个条件为真。如果一个线程正在等待第二个线程完成一个任务，有几种方式，第一，可以一直检测共享数据中的标志位，让第二个线程完成任务后设置标志位，这种方式非常浪费资源。第二个选择是让等待线程利用<code>std::this_thread::sleep_for()</code>函数在检查之间睡眠一段时间，这种方式比第一种有所提升，在线程睡眠时不需要浪费处理时间，但是很难设定合适的睡眠周期。第三种方式是使用c++标注库中的<code>condition variables</code>。条件变量与某个事件或条件相关联，一个或多个线程可以等待条件满足，当一个线程决定条件变量受到满足，然后就可以通知一个或多个等待条件变量的线程，唤醒它们并允许它们继续处理。</p>
<h2 id="使用条件变量等待一个条件">使用条件变量等待一个条件</h2>
<p>标准库提供了<code>std::condition_variable</code>和<code>std::condition_variable_any</code>，前者与<code>std::mutex</code>配合使用，后者与任何满足最小条件的类似互斥量工作。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">std::mutex m;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;</span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line">void data_preparation_thread()</span><br><span class="line">&#123;</span><br><span class="line">    while(more_data_to_prepare())</span><br><span class="line">    &#123;</span><br><span class="line">        data_chunk const data &#x3D; prepare_data();</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lk(m);</span><br><span class="line">        data_queue.push(data);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void data_processing_thread()</span><br><span class="line">&#123;</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lk(m);</span><br><span class="line">        data_cond.wait(lk, []&#123;return !data_queue.empty();&#125;);</span><br><span class="line">        data_chunk data&#x3D;data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        lk.unlock();</span><br><span class="line"></span><br><span class="line">        process(data);</span><br><span class="line">        if(is_last_chunk(data))</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对于数据准备线程，当数据准备好时，线程利用<code>std::lock_guard</code>对互斥量加锁保护队列，并把数据加入到队列中，接着调用<code>notify_one()</code>通知等待线程。数据处理线程首先使用<code>std::unique_lock</code>对互斥量加锁，然后调动<code>wait()</code>传入等待条件的函数对象。<code>wait()</code>的实现检查条件是否满足，如果不满足，<code>wait()</code>对互斥量解锁，阻塞线程或进入等待状态。当条件通过数据准备线程<code>notify_one()</code>被通知时，数据处理线程被唤醒，获取互斥量上的锁，再次检查条件，如果条件满足从<code>wait()</code>返回的互斥量依然是加锁的 使用条件变量构建线程安全队列 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class threadsafe_queue</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    mutable std::mutex mut; &#x2F;&#x2F; the mutex must be mutable</span><br><span class="line">    std::queue&lt;T&gt; data_queue;</span><br><span class="line">    std::condition_variable data_cond;</span><br><span class="line">public:</span><br><span class="line">   threadsafe_queue()&#123;&#125;</span><br><span class="line">   threadsafe_queue(threadsafe_queue const&amp; other)</span><br><span class="line">   &#123;</span><br><span class="line">       std::lock_guard&lt;std::mutex&gt; lk(other.mut);</span><br><span class="line">       data_queue &#x3D; other.data_queue;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   void push(T new_value)</span><br><span class="line">   &#123;</span><br><span class="line">       std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">       data_queue.push(new_value);</span><br><span class="line">       data_cond.notify_one();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   void wait_and_pop(T&amp; value)</span><br><span class="line">   &#123;</span><br><span class="line">       std::unique_lock&lt;std::mutex&gt; lk(mut);</span><br><span class="line">       data_cond.wait(lk, [this]&#123;return !data_queue.empty();&#125;);</span><br><span class="line">       value&#x3D;data_queue.front();</span><br><span class="line">       data_queue.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   std::shared_ptr&lt;T&gt; wait_and_pop()</span><br><span class="line">   &#123;</span><br><span class="line">       std::unique_lock&lt;std::mutex&gt; lk(mut);</span><br><span class="line">       data_cond.wait(lk, [this]&#123;return !data_queue.empty();&#125;);</span><br><span class="line">       std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front()));</span><br><span class="line">       data_queue.pop();</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   bool try_pop(T&amp; value)</span><br><span class="line">   &#123;</span><br><span class="line">       std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">       if(data_queue.empty())</span><br><span class="line">           return false;</span><br><span class="line">       value&#x3D;data_queue.front();</span><br><span class="line">       data_queue.pop();</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   std::shared_ptr&lt;T&gt; try_pop()</span><br><span class="line">   &#123;</span><br><span class="line">       std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">       if(data_queue.empty())</span><br><span class="line">           return std::shared_ptr&lt;T&gt;();</span><br><span class="line">       std::shared_ptr&lt;T&gt; res(std::make_shared&lt;T&gt;(data_queue.front()));</span><br><span class="line">       data_queue.pop();</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   bool empty() const</span><br><span class="line">   &#123;</span><br><span class="line">       std::lock_guard&lt;std::mutex&gt; lk(mut);</span><br><span class="line">       return data_queue.empty();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 尽管<code>empty()</code>是一个常量成员函数，复制构造函数中的other参数是一个常量引用，其他线程可能有对象的非常量引用，会调用能够修改的成员函数，因此我们依然需要对互斥量加锁，由于这是一个修改操作，互斥量必须标记为<code>mutable</code>。 条件变量对于多个线程等待相同事件也是有用的，如果新数据已经准备，调用<code>notify_one()</code>会触发某一个线程执行<code>wait()</code>检查条件并从<code>wait()</code>返回。这并不保证哪个线程被通知；另一种可能是多个线程等待同一个事件，但是所有的线程都需要回应。这时数据准备线程可以调用<code>notify_all()</code>,会触发所有当前执行<code>wait()</code>的线程检查等待的条件；如果等待线程只等待一次，如果条件是true，线程将不再等待这个条件变量，这时就需要使用future。</p>
<h2 id="使用futures等待一次性事件">使用futures等待一次性事件</h2>
<p>C++标准库使用futrue建模一次性事件。如果一个线程需要等待一个特定的一次性事件，可以说它获得了代表这个事件的一个期望。 线程可以在一段事件内周期地等待期望看是否事件发生，在检测之间可以执行其他的任务。C++标准库实现了两个future的模板类： <code>unique futures(std::future&lt;&gt;)</code>和<code>shared futures（std::shared_future&lt;&gt;)</code>。<code>std::future</code>是指向它关联事件的仅有的一个实例。<code>std::shared_future</code>的多个实例可以指向同一个事件。</p>
<h2 id="从后台任务中返回值">从后台任务中返回值</h2>
<p>假设你有一个需要长时间运行的计算，并期望最终会得到一个有用的结果，但现在并不需要这个值。你可以开启一个新的线程去执行计算，但是 这意味着你必须要把结果转移回来，<code>std::thread</code>并不提供这样的机制。这时就需要<code>std::async</code>，使用<code>std::async</code>可以开启一个你并不马上需要结果的异步任务，<code>std::async</code>返回一个<code>std::future</code>对象，会包含函数的返回值。当你需要该值的时候，只需要在future对象上调用<code>get()</code>函数。线程就会阻塞直到future对象ready，并返回值。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int find_the_answer_to_ltuae();</span><br><span class="line">void do_other_stuff();</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::future&lt;int&gt; the_answer &#x3D; std::async(find_the_answer_to_ltuae);</span><br><span class="line">    do_other_stuff();</span><br><span class="line">    std::cout&lt;&lt;&quot;The answer is &quot;&lt;&lt;the_answer.get()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">与std::thread类似，std::async允许你传递给函数额外的参数，例如：</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">struct X</span><br><span class="line">&#123;</span><br><span class="line">    void foo(int, std::string const&amp;);</span><br><span class="line">    std::string bar(std::string const&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line">auto f1&#x3D;std::async(&amp;X::foo, &amp;x, 42, &quot;hello&quot;); &#x2F;&#x2F; calls p-&gt;foo(42, &quot;hello&quot;) where p is &amp;x</span><br><span class="line">auto f2&#x3D;std::async(&amp;X::bar, x, &quot;goodbye&quot;); &#x2F;&#x2F; calls tempx.bar(&quot;goodbye&quot;) where tempx is a copy of x</span><br><span class="line">struct Y</span><br><span class="line">&#123;</span><br><span class="line">    double operator(double);</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line">auto f3&#x3D;std::async(Y(), 3.141); &#x2F;&#x2F; calls tmpy(3.141) where tmpy is move-constructed from Y()</span><br><span class="line">auto f4&#x3D;std::async(std::ref(y),2.718); &#x2F;&#x2F; calls y(2.718)</span><br><span class="line">X baz(X&amp;);</span><br><span class="line">std::async(baz, std::ref(x)); &#x2F;&#x2F; calls baz(x)</span><br><span class="line">class move_only</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    move_only();</span><br><span class="line">    move_only(move_only&amp;&amp;)</span><br><span class="line">    move_only(move_only const&amp;) &#x3D; delete;</span><br><span class="line">    move_only&amp; operator&#x3D;(move_only&amp;&amp;);</span><br><span class="line">    move_only&amp; operator&#x3D;(move_only const&amp;) &#x3D; delete;</span><br><span class="line"></span><br><span class="line">    void operator()();</span><br><span class="line">&#125;;</span><br><span class="line">auto f5 &#x3D; std::async(move_only()); &#x2F;&#x2F; calls tmp() where tmp is constructed from std::move(move_only())</span><br></pre></td></tr></table></figure> <code>std::async</code>还可以接受<code>std::launch</code>类型的参数，可以指定<code>std::launch::deferred</code>或<code>std::launch::async</code>。前者指示函数调用将被延迟，直到 在future上调用<code>wait()</code>或者<code>get()</code>。后者指示函数必须运行在自己的线程之上。还可以指定s<code>td::launch::deferred|std::launch::async</code>来表明实现可以选择</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto f6&#x3D;std::async(std::launch::async, Y(), 1.2); &#x2F;&#x2F; Run in new thread</span><br><span class="line">auto f7&#x3D;std::async(std::launch::deferred, baz, std::ref(x)); &#x2F;&#x2F; Run in wait() or get()</span><br><span class="line">auto f8&#x3D;std::async(std::launch::deferred|std::launch::async, baz, std::ref(x)); &#x2F;&#x2F; Implementation chooses</span><br><span class="line">auto f9 &#x3D; std::async(baz, std::ref(x)); &#x2F;&#x2F; Implementation chooses</span><br><span class="line">f7.wait(); &#x2F;&#x2F; Invoke deferred function</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="任务与期望关联">任务与期望关联</h2>
<p><code>std::packaged_task&lt;&gt;</code>可以将期望绑定到一个函数或可调用对象上。当<code>std::packaged_task&lt;&gt;</code>对象调用，它会调用关联的函数或可调用对象，使期望就绪，并将返回值存储为关联数据。<code>std::packaged_task&lt;&gt;</code>类模板的模板参数是一个函数签名，从<code>get_future()</code>成员函数返回的<code>std::future&lt;&gt;</code>的类型由指定函数签名的返回值确定。函数签名的参数列表用来说明任务的函数调用操作符的签名。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;&gt;</span><br><span class="line">class packaged_task&lt;std::string(std::vector&lt;char&gt;*, int)&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    template&lt;typename Callable&gt;</span><br><span class="line">    explicit packaged_task(Callable&amp;&amp; f);</span><br><span class="line">    std::future&lt;std::string&gt; get_future();</span><br><span class="line">    void operator()(std::vector&lt;char&gt;*, int);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> <code>std::packaged_task</code>对象是一个可调用对象，可以封装到<code>std::function</code>对象中，传递给<code>std::thread</code>作为线程函数，传递给另一个 需要一个可调用对象的函数，或者直接调用。 许多GUI框架需要特定的线程来完成GUI的更新，所以如果其他线程需要更新GUI，它必须发送一个消息给到正确的线程。std::packaged_task提供 了完成这种功能的一种方法，且不需要发送自定义信息给GUI相关线程。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;deque&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;utility&gt;</span><br><span class="line"></span><br><span class="line">std::mutex m;</span><br><span class="line">std::deque&lt;std::packaged_task&lt;void()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line">bool gui_shutdown_message_received();</span><br><span class="line">void get_and_process_gui_message();</span><br><span class="line"></span><br><span class="line">void gui_thread()</span><br><span class="line">&#123;</span><br><span class="line">    while(!gui_shutdown_message_received())</span><br><span class="line">    &#123;</span><br><span class="line">        get_and_process_gui_message();</span><br><span class="line">        std::packaged_task&lt;void()&gt; task;</span><br><span class="line">        &#123;</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; lk(m);</span><br><span class="line">            if(tasks.empty())</span><br><span class="line">                continue;</span><br><span class="line">            </span><br><span class="line">            task&#x3D;std::move(tasks.front());</span><br><span class="line">            tasks.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        task();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::thread gui_bg_thread(gui_thread);</span><br><span class="line"></span><br><span class="line">template&lt;typename Func&gt;</span><br><span class="line">std::future&lt;void&gt; post_task_for_gui_thread(Func f)</span><br><span class="line">&#123;</span><br><span class="line">    std::package_task&lt;void()&gt; task(f);</span><br><span class="line">    std::future&lt;void&gt; res &#x3D; task.get_future();</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lk(m);</span><br><span class="line">    tasks.push_back(std::move(task));</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用stdpromises">使用std::promises</h2>
<p><code>std::promise&lt;T&gt;</code>提供一种设置值（类型T)的方式，可以通过一个关联的<code>std::future&lt;T&gt;</code>对象来读取。 一个<code>std::promise/std::future</code>组合为这种方式提供了一种可行的机制；等待线程在期望上阻塞，而提供数据的 线程可以使用承诺来设置相关值，并使期望就绪。 像<code>std::packaged_task</code>一样，你可以通过调用<code>get_future()</code>成员函数获得给定<code>std::promise</code>关联的<code>std::future</code>对象。 当承诺的值设定后，期望变为就绪状态，可以用来获取存储的值。如果你在设置值之前销毁<code>std::promise</code>，将会存储一个异常。 下面的例子是一个线程处理多个链接的代码。这个例子中，使用<code>std::promise&lt;bool&gt;/std::future&lt;bool&gt;</code>组合来确定输出数据的 成功发送，和期望相关的值只是简单的成功/失败标识。对于输入包，和期望相关的数据是数据包中的有效载荷。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;future&gt;</span><br><span class="line"></span><br><span class="line">void process_connections(connection_set&amp; connections)</span><br><span class="line">&#123;</span><br><span class="line">  while(!done(connections))  &#x2F;&#x2F; 1</span><br><span class="line">  &#123;</span><br><span class="line">    for(connection_iterator  &#x2F;&#x2F; 2</span><br><span class="line">            connection&#x3D;connections.begin(),end&#x3D;connections.end();</span><br><span class="line">          connection!&#x3D;end;</span><br><span class="line">          ++connection)</span><br><span class="line">    &#123;</span><br><span class="line">      if(connection-&gt;has_incoming_data())  &#x2F;&#x2F; 3</span><br><span class="line">      &#123;</span><br><span class="line">        data_packet data&#x3D;connection-&gt;incoming();</span><br><span class="line">        std::promise&lt;payload_type&gt;&amp; p&#x3D;</span><br><span class="line">            connection-&gt;get_promise(data.id);  &#x2F;&#x2F; 4</span><br><span class="line">        p.set_value(data.payload);</span><br><span class="line">      &#125;</span><br><span class="line">      if(connection-&gt;has_outgoing_data())  &#x2F;&#x2F; 5</span><br><span class="line">      &#123;</span><br><span class="line">        outgoing_packet data&#x3D;</span><br><span class="line">            connection-&gt;top_of_outgoing_queue();</span><br><span class="line">        connection-&gt;send(data.payload);</span><br><span class="line">        data.promise.set_value(true);  &#x2F;&#x2F; 6</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="为期望存储异常">为期望存储异常</h2>
<p><code>std::promise</code>提供了<code>set_exception()</code>成员函数来存储异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extern std::promise&lt;double&gt; some_promise;</span><br><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    some_promise.set_value(calculate_value());</span><br><span class="line">&#125;</span><br><span class="line">catch(...)</span><br><span class="line">&#123;</span><br><span class="line">    some_promise.set_exception(std::current_exception());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外一种方式是使用<code>std::copy_exception()</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_promise.set_exception(std::copy_exception(std::logic_error(&quot;foo &quot;)));</span><br></pre></td></tr></table></figure></p>
<h2 id="等待多个线程">等待多个线程</h2>
<p>尽管<code>std::future</code>处理将数据从一个线程到另一个线程的所有同步需求，调用一个特定<code>std::futrue</code>实例的成员函数在线程之间是没有同步的。 如果你从多个线程中访问<code>std::future</code>对象，没有进行同步，将会遇到data race和未定义行为。标准库提供了<code>std::shared_future</code>来处理这种情况，<code>std::future</code>只是moveable，<code>std::shared_future</code>实例是copyable的。由于std::future对象不和其他对象共享异步状态的所有权，所以需要使用<code>std::move</code>将所有权从<code>std::future</code>转移给<code>std::shared_future</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;int&gt; p;</span><br><span class="line">std::future&lt;int&gt; f(p.get_future());</span><br><span class="line">assert(f.valid()); &#x2F;&#x2F; the future f is valid</span><br><span class="line">std::shared_future&lt;int&gt; sf(std::move(f)); </span><br><span class="line">assert(!f.valid()); &#x2F;&#x2F; f is no longer valid</span><br><span class="line">assert(sf.valid()); &#x2F;&#x2F; sf is now valid</span><br></pre></td></tr></table></figure>
<h2 id="等待一段时间">等待一段时间</h2>
<p>有两种等待一段时间的方式:基于时间段duration-base，绝对的时间点，前者通常有_for形式的后缀，后者以_until结尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Waiting for a condition variable with a timeout</span><br><span class="line">#include &lt;condition_variale&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line">bool done;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line">bool wait_loop()</span><br><span class="line">&#123;</span><br><span class="line">    auto const timeout &#x3D; std::chrono::steady_clock::now() + std::chrono::milliseconds(500);</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(m);</span><br><span class="line">    while(!done)</span><br><span class="line">    &#123;</span><br><span class="line">        if(cv.wait_until(lk,timeout) &#x3D;&#x3D; std::cv_status::timeout)</span><br><span class="line">           break;</span><br><span class="line">    &#125;</span><br><span class="line">    return done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用暂停最简单的例子是在一个线程处理中添加延迟，这样就不会在自己不工作的时候，不会占用其他线程的处理时间，常用的两个函数 是<code>std::this_thread::sleep_for()</code>和<code>std::this_thread::sleep_until()</code>。</p>
<h2 id="使用同步操作来简化代码">使用同步操作来简化代码</h2>
<p>函数式风格的QuichSORT <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A sequential implementation of quicksort</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">std::list&lt;T&gt; sequential_quick_sort(std::list&lt;T&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">    if(input.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    result.splice(result.begin(), input, input.begin());</span><br><span class="line">    T const&amp; pivot &#x3D; *result.begin();</span><br><span class="line"></span><br><span class="line">    auto divide_point&#x3D;std::partition(input.begin(), input.end(), [&amp;](T const&amp; t)&#123;return t&lt;pivot;&#125;);</span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.splice(lower_part.end(),input,input.begin(),divide_point);</span><br><span class="line"></span><br><span class="line">    auto new_lower(sequential_quick_sort(std::move(lower_part)));</span><br><span class="line">    auto new_higher(sequential_quick_sort(std::move(input)));</span><br><span class="line"></span><br><span class="line">    result.splice(result.end(),new_higher);</span><br><span class="line">    result.splice(result.begin(),new_lower);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数式风格的并行Quicksort</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">std::list&lt;T&gt; parallel_quick_sort(std::list&lt;T&gt; input)</span><br><span class="line">&#123;</span><br><span class="line">    if(input.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        return input;</span><br><span class="line">    &#125;</span><br><span class="line">    std::list&lt;T&gt; result;</span><br><span class="line">    result.splice(result.begin(),input, input.begin());</span><br><span class="line">    T const&amp; pivot &#x3D; *result.begin();</span><br><span class="line">    auto divide_point&#x3D;std::partition(input.begin(),input.end(),[&amp;](T const&amp; t)&#123;return t&lt;pivot;&#125;);</span><br><span class="line"></span><br><span class="line">    std::list&lt;T&gt; lower_part;</span><br><span class="line">    lower_part.splice(lower_part.end(),input,input.begin(),divide_point);</span><br><span class="line">    std::future&lt;std::list&lt;T&gt;&gt; new_lower(std::async(&amp;parallel_quick_sort&lt;T&gt;,std::move(lower_part)));</span><br><span class="line"></span><br><span class="line">    auto new_higher(parallel_quick_sort(std::move(input)));</span><br><span class="line"></span><br><span class="line">    result.splice(result.end(), new_higher);</span><br><span class="line">    result.splice(result.begin(), new_lower.get());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/17/cpp-concurrency-sharing-data-between-threads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/17/cpp-concurrency-sharing-data-between-threads/" class="post-title-link" itemprop="url">cpp-concurrency-sharing-data-between-threads</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-09-17 18:52:29" itemprop="dateCreated datePublished" datetime="2020-09-17T18:52:29+00:00">2020-09-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="线程间数据共享问题">线程间数据共享问题</h1>
<p>线程间的数据共享问题都是由于对数据的修改。如果所有共享的数据是只读的，就没有问题，因为一个线程读取的数据并不因为另外一个线程是否正在读取同样的数据而受影响。在并发中，任何输出结果依赖于两个或多个线程执行的相对顺序时就构成了竞争条件（race conditon)。C++标准定义了data race, 指由于同时对一个单一对象做修改而引起竞争条件的情况。</p>
<p>C++标准中保护共享数据最基本的机制是使用互斥变量mutex。在访问共享数据结构之前，对数据关联的互斥变量加锁lock，在完成访问数据后，进行解锁unlock。</p>
<h2 id="使用互斥变量保护共享数据">使用互斥变量保护共享数据</h2>
<p>C++中通过<code>std::mutex</code>来创建一个互斥量，通过<code>lock()</code>和<code>unlock()</code>函数来进行加锁和解锁。标准库提供了<code>std::lock_guard</code>，实现了互斥变量的RAII机制，构造时加锁，析构时解锁，从而避免手动进行加锁和解锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">std::list&lt;int&gt; some_list;</span><br><span class="line">std::mutex some_mutex;</span><br><span class="line"></span><br><span class="line">void add_to_list(int new_value)</span><br><span class="line">&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; guard(some_mutex);</span><br><span class="line">    some_list.push_back(new_value);</span><br><span class="line">&#125;</span><br><span class="line">bool list_contains(int value_to_find)</span><br><span class="line">&#123;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; guard(some_mutex);</span><br><span class="line">    return std::find(some_list.begin(), some_list.end(), value_to_find) !&#x3D; some_list.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stucturing-code-for-protecting-shared-data">Stucturing code for protecting shared data</h3>
<p>通常互斥量和共享数据作为类的私有成员变量，如果类的成员函数在访问数据成员时加锁，结束后解锁，数据可以很好地受到保护，但是对于返回保护数据指针或者引用的成员函数并不是这样，因为任何获取到数据指针或者引用的代码都可以在没有加锁的情况下访问保护数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class some_data</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    std::string b;</span><br><span class="line">public:</span><br><span class="line">    void do_something();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class data_wrapper</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    some_data data;</span><br><span class="line">    std::mutex m;</span><br><span class="line">public:</span><br><span class="line">    template&lt;typename Function&gt;</span><br><span class="line">    void process_data(Function func)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; l(m);</span><br><span class="line">        func(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data* unprotected;</span><br><span class="line"></span><br><span class="line">void malicious_function(some_data&amp; protected_data)</span><br><span class="line">&#123;</span><br><span class="line">    unprotected&#x3D;&amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    x.process_data(malicious_function);</span><br><span class="line">    unprotected-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要在锁的作用域范围之外传递保护数据的指针和引用，不管是通过从一个函数返回，在外部显示内存存储，或者作为参数传递给用户提供的函数</p>
<h3 id="spotting-race-conditons-inherent-in-interface">Spotting race conditons inherent in interface</h3>
<p>考虑stack类，有五个操作<code>push()</code>，<code>pop()</code>,<code>top()</code>,<code>empty()</code>,<code>size()</code>。如果你更改<code>top()</code>返回一个复制而不是引用，并用互斥量来保护内部数据，这个接口仍然会有竞速条件问题。 当stack实例不是共享时，检查<code>empty()</code>然后调用<code>top()</code>获取栈顶元素是安全的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;int&gt; s;</span><br><span class="line">if(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">    int const value &#x3D; s.top();</span><br><span class="line">    s.pop();</span><br><span class="line">    do_something(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当stack对象是共享时，这个调用顺序就不再是安全的了，在调用<code>empty()</code>和<code>top()</code>之间，另一个线程可能调用<code>pop()</code>移除最后一个元素。在top()和pop()调用直接也存在潜在的竞速条件。一个可能的执行顺序如下： <img src="/2020/09/17/cpp-concurrency-sharing-data-between-threads/table3_1.png" class="" title="table3_1"> 在两个<code>top()</code>中间没有操作修改stack，两个线程返回的<code>top()</code>值是一样的，在两个<code>pop()</code>中间也没有调用<code>top()</code>，结果就是栈上两个值的其中一个在没有被读取的情况下被丢弃了。正是由于top和pop()操作分离的设计导致了竞争条件。</p>
<h4 id="option-1-pass-in-a-reference">Option 1: Pass In A REFERENCE</h4>
<p>第一个选择是传递一个变量的引用作为pop()函数的参数 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; result;</span><br><span class="line">some_stack.pop(result);</span><br></pre></td></tr></table></figure> 缺点：需要在调用之前构造栈类型对象</p>
<h4 id="option-2-require-a-no-throw-copy-constructor-or-move-constructor">Option 2: Require a no-throw copy constructor or move constructor</h4>
<p><code>pop()</code>操作只有以传值方式返回抛出异常这一种异常安全问题。许多类型的复制构造函数不抛出异常，具有移动构造函数的类型也不抛出异常即使其复制构造函数抛出异常。</p>
<h4 id="option-3-return-a-pointer-to-the-popped-item">Option 3： Return a pointer to the popped item</h4>
<p>第三种方式是返回一个弹出项的指针而不是返回值，优点是指针可以自由拷贝而不抛出异常</p>
<h4 id="option-4-provide-both-option-1-and-either-option-2-or-3">Option 4: Provide both Option 1 and either option 2 or 3</h4>
<p>提供给用户选择最合适的选项的能力 线程安全的stack类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;exception&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line"></span><br><span class="line">struct empty_stack : std::exception</span><br><span class="line">&#123;</span><br><span class="line">    const char* what() const throw();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class threadsafe_stack</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    std::stack&lt;T&gt; data;</span><br><span class="line">    mutable std::mutex m;</span><br><span class="line">public:</span><br><span class="line">    threadsafe_stack()&#123;&#125;</span><br><span class="line">    threadsafe_stack(const threadsafe_stack&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        data&#x3D;other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; operator&#x3D;(const threadsafe_stack&amp;) &#x3D; delete;</span><br><span class="line"></span><br><span class="line">    void push(T new_value)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        data.push(new_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;T&gt; pop()</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        if(data.empty()) throw empty_stack();</span><br><span class="line">        std::shared_ptr&lt;T&gt; const res(std::make_shared&lt;T&gt;(data.top()));</span><br><span class="line">        data.pop();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void pop(T&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        if(data.empty()) throw empty_stack();</span><br><span class="line">        value &#x3D; data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bool empty() const</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock(m);</span><br><span class="line">        return data.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="死锁">死锁</h2>
<p>两个线程需都要对两个互斥量加锁来执行某些操作，每个线程都有一个互斥量，等待另一个释放自己的互斥量，这种情况叫做死锁。避免死锁的通常建议是始终按相同的顺序对两个互斥量加锁。但是有些时候并不是那么简单，考虑交换同一个类的两个实例的数据时，为了确保数据不被并发修改影响正确交换，两个实例的互斥量都需要加锁，这种情况下顺序加锁就会出现死锁现象。<code>std::lock</code>可以同时对两个或多个互斥量加锁避免死锁风险。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class some_big_object;</span><br><span class="line">void swap(some_big_object&amp; lhs, some_big_object&amp; rhs);</span><br><span class="line"></span><br><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line">public:</span><br><span class="line">    X(some_big_object const&amp; sd):some_detail(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend void swap(X&amp; lhs, X&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;lhs&#x3D;&#x3D;&amp;rhs)</span><br><span class="line">            return;</span><br><span class="line">        std::lock(lhs.m, rhs.m);</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m, std::adopt_lock);</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std::adopt_lock);</span><br><span class="line">        swap(lhs.some_detail, rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::adopt_lock</code> 参数是为了告诉<code>std::lock_guard</code>对象互斥量已经被加锁，只需要获取互斥量上锁的所有权，而不用在构造函数里对互斥量加锁。</p>
<h3 id="避免死锁的指导原则">避免死锁的指导原则</h3>
<h4 id="避免嵌套锁">避免嵌套锁</h4>
<p>如果你已经拥有一个锁不要再获取另一个，如果需要获取多个锁，使用<code>std::lock</code>执行一次动作获取。</p>
<h4 id="拥有一个锁时避免调用用户提供的代码">拥有一个锁时避免调用用户提供的代码</h4>
<p>如果代码是用户提供的，你不知道它做了什么，可能包括获取一个锁。</p>
<h4 id="以固定顺序获取锁">以固定顺序获取锁</h4>
<p>如果确实需要获取两个或多个锁，又不能用std::lock一次操作获取，最好的方式是在每个线程中按相同的顺序获取。代价是不允许反向遍历</p>
<h4 id="使用锁分层结构">使用锁分层结构</h4>
<p>思想是把你的应用划分到各个层里，并确定在任何给定层可能被加锁的互斥量。当代码试图对互斥量加锁时，如果已经从低层拥有一个锁，就会禁止它对互斥量加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">hierarchical_mutex high_level_mutex(10000);</span><br><span class="line">hierarchical_mutex low_level_mutex(5000);</span><br><span class="line"></span><br><span class="line">int do_low_level_stuff();</span><br><span class="line">int low_level_func()</span><br><span class="line">&#123;</span><br><span class="line">    std::lock_guard&lt;hierarchical_mutex&gt; lk(low_level_mutex);</span><br><span class="line">    return do_low_level_stuff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void high_level_stuff(int some_param);</span><br><span class="line"></span><br><span class="line">void high_level_func()</span><br><span class="line">&#123;</span><br><span class="line">    std::lock_guard&lt;hierarchical_mutex&gt; lk(high_level_mutex);</span><br><span class="line">    high_level_stuff(low_level_func());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void thread_a()</span><br><span class="line">&#123;</span><br><span class="line">    high_level_func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hierarchical_mutex_othre_mutex(100);</span><br><span class="line">void do_other_stuff();</span><br><span class="line"></span><br><span class="line">void other_stuff()</span><br><span class="line">&#123;</span><br><span class="line">    high_level_func();</span><br><span class="line">    do_other_stuff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void thread_b()</span><br><span class="line">&#123;</span><br><span class="line">    std::lock_guard&lt;hierarchical_mutex&gt; lk(other_mutex);</span><br><span class="line">    other_stuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>thread_a()</code>遵循这个规则，可以正常运行。<code>thread_b()</code>没有遵循规则，首先，它对<code>other_mutex</code>这个100的低层级互斥量加锁。当<code>other_stuff()</code>调用<code>high_level_func()</code>时，违法了层级规则：<code>high_level_func()</code>试图获取<code>high_level_mutex</code>,它的层级值（10000）比当前的层级值(100)要高。<code>hierarchical_mutex</code>将会报告一个错误，抛出异常或终止程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class hierarchical_mutex</span><br><span class="line">&#123;</span><br><span class="line">    std::mutex internal_mutex;</span><br><span class="line">    unsigned long const hierarchy_value;</span><br><span class="line">    unsigned long previous_hierarchy_value;</span><br><span class="line">    static thread_local unsigned long this_thread_hierarchy_value;</span><br><span class="line"></span><br><span class="line">    void check_for_hierarchy_violation()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this_thread_hierarchy_value &lt;&#x3D; hierarchy_value)</span><br><span class="line">        &#123;</span><br><span class="line">            throw std::logic_error(&quot;mutex hierarchy violated);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void update_hierarchy_value()</span><br><span class="line">    &#123;</span><br><span class="line">        previous_hierarchy_value &#x3D; this_thread_hierarchy_value;</span><br><span class="line">        this_thread_hierarchy_value &#x3D; hierarchy_value;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    explicit hierarchical_mutex(unsigned long value):</span><br><span class="line">        hierarchy_value(value),</span><br><span class="line">        previous_hierarchy_value(0)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void lock()</span><br><span class="line">    &#123;</span><br><span class="line">        check_for_hierarchy_violation();</span><br><span class="line">        internal_mutex.lock();</span><br><span class="line">        update_hierarchy_value();</span><br><span class="line">    &#125;</span><br><span class="line">    void unlock()</span><br><span class="line">    &#123;</span><br><span class="line">        this_thread_hierarchy_value&#x3D;previous_hierarchy_value;</span><br><span class="line">        internal_mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    bool try_lock()</span><br><span class="line">    &#123;</span><br><span class="line">        check_for_hierarchy_violation();</span><br><span class="line">        if(!internal_mutex.try_lock())</span><br><span class="line">            return false;</span><br><span class="line">        update_hierarchy_value();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">thread_local unsigned long hierarchical_mutex::this_thread_hierarchy_value(ULONG_MAX);</span><br></pre></td></tr></table></figure>
<h2 id="stdunique_lock">std::unique_lock</h2>
<p><code>std::unique_lock</code>比<code>std::lock_guard</code>提供了更多地灵活性；<code>std::unique_lock</code>实例并不是一直拥有与它关联的互斥量。首先，你可以传递<code>std::adopt_lock</code>作为第二个参数给构造函数使锁对象管理互斥量上的锁，你也可以传递<code>std::defer_lock</code>作为第二个参数来指示互斥量应该在构造时保持解锁状态。通过在<code>std::unique_lock</code>对象上调用<code>lock()</code>或者传递<code>std::unique_lock</code>对象给<code>std::lock()</code>来进行加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class some_big_object;</span><br><span class="line">void swap(some_big_object&amp; lhs, some_big_object&amp; rhs);</span><br><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    some_big_object some_detail;</span><br><span class="line">    std::mutex m;</span><br><span class="line">public:</span><br><span class="line">    X(some_big_object const&amp; sd):some_detail(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend void swap(X&amp; lhs, X&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;lhs&#x3D;&#x3D;&amp;rhs)</span><br><span class="line">            return;</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock_a(lhs.m, std::defer_lock);</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock_b(rhs.m, std::defer_lock);</span><br><span class="line">        std::lock(lock_a, lock_b);</span><br><span class="line">        swap(lhs.some_detail, rhs.some_detail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>std::unique_lock</code>会在内部存储一个是否拥有锁的标志，<code>std::unique_lock</code>对象会比<code>std::lock_guard</code>大，而且需要更新或检查标志位。如果<code>std::lock_guard</code>满足需求，建议使用<code>std::lock_guard</code>。 ## 在不同作用域转移互斥量的所有权 由于<code>std::unique_lock</code>实例并不是一定拥有他们关联的互斥量，互斥量的所有权可以通过moving来在实例间转换。 如果是从函数返回一个实例，这种转换是自动的，其他情况你需要显示调用<code>std::move()</code>，这取决于变量是左值(一个真正变量）还是右值（临时变量），右值自动转换，左值需要显示转换。<code>std::unique_lock</code>可以movable但不可以copyable。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::unique_lock&lt;std::mutex&gt; get_lock()</span><br><span class="line">&#123;</span><br><span class="line">    extern std::mutex some_mutex;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(some_mutex);</span><br><span class="line">    prepare_data();</span><br><span class="line">    return lk;</span><br><span class="line">&#125;</span><br><span class="line">void process_data()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(get_lock());</span><br><span class="line">    do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="选择合适的加锁粒度">选择合适的加锁粒度</h2>
<p>一个细粒度的锁保护数据的一小部分，一个粗粒度的锁保护数据的一大部分。既需要选择合适的粗粒度锁来确保数据受保护，又需要确保只有实际访问共享数据的时候锁才被持有。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void get_and_process_data()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; my_lock(the_mutex);</span><br><span class="line">    some_class data_to_process&#x3D;get_next_data_chunk();</span><br><span class="line">    my_lock.unlock();</span><br><span class="line">    result_type result &#x3D; process(data_to_process);</span><br><span class="line">    my_lock.lock();</span><br><span class="line">    write_result(data_to_process, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你不需要在调用<code>process()</code>时对互斥量加锁，所以在<code>process()</code>之前进行解锁，在write_result之前进行加锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Y</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int some_detail;</span><br><span class="line">    mutable std::mutex m;</span><br><span class="line">    </span><br><span class="line">    int get_detail() const</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lock_a(m);</span><br><span class="line">        return some_detail;</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    Y(int sd):some_detail(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    friend bool operator&#x3D;&#x3D;(Y const&amp; lhs, Y const&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        if(&amp;lhs&#x3D;&#x3D;&amp;rhs)</span><br><span class="line">            return true;</span><br><span class="line">        int const lhs_value&#x3D;lhs.get_detail();</span><br><span class="line">        int const rhs_value&#x3D;rhs.get_detail();</span><br><span class="line">        return lhs_value&#x3D;&#x3D;rhs_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，虽然降低了锁的周期，每次只拥有一个锁，这其实改变了比较操作的语义，这里操作符返回true代表某一时刻lhs.some_detail的值等于另一时刻rhs.some_detail的值。</p>
<h2 id="保护共享数据的其他方式">保护共享数据的其他方式</h2>
<p>互斥量并不是唯一保护共享数据的方式；一种特殊的情况是共享数据只需要初始化时对并发访问进行保护，之后并不需要显式同步。这种情况对初始化后的数据进行加锁不是必要的而且对性能会有影响。</p>
<h3 id="初始化时保护共享数据">初始化时保护共享数据</h3>
<p>利用mutex实现线程安全的延迟初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lk(resource_mutex); &#x2F;&#x2F; all threads are serialized here</span><br><span class="line">    if(!resource_ptr)</span><br><span class="line">    &#123;</span><br><span class="line">        resource_ptr.reset(new some_resource); &#x2F;&#x2F; only the initialization needs protection</span><br><span class="line">    &#125;</span><br><span class="line">    lk.unlock();</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了检查资源是否已经被初始化，每个线程都需要等待互斥量。另一种实现是Double-Checked Locking模式,但是 会导致未定义行为，因为锁范围之外的读取并没有与锁内部由另一线程的写入操作同步。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void undefined_behaviour_with_double_checked_locking()</span><br><span class="line">&#123;</span><br><span class="line">    if(!resource_ptr) &#x2F;&#x2F; 1</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; lk(resource_mutex);</span><br><span class="line">        if(!resource_ptr) &#x2F;&#x2F; 2</span><br><span class="line">        &#123;</span><br><span class="line">            resource_ptr.reset(new some_resource); &#x2F;&#x2F; 3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    resource_ptr-&gt;do_something(); &#x2F;&#x2F; 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> C++标准库提供了<code>std::once_flag</code>和<code>std::call_once</code>来处理这种情况 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::once_flag resource_flag;</span><br><span class="line"></span><br><span class="line">void init_resource()</span><br><span class="line">&#123;</span><br><span class="line">    resource_ptr.reset(new some_resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void foo()</span><br><span class="line">&#123;</span><br><span class="line">    std::call_once(resource_flag, init_resource);</span><br><span class="line">    resource_ptr-&gt;do_something();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>std::once_flag</code>和<code>std::call_once()</code>同样可以作为类成员的延迟初始化。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class x</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    connection_info connection_details;</span><br><span class="line">    connection_handle connection;</span><br><span class="line">    std::once_flag connection_init_flag;</span><br><span class="line"></span><br><span class="line">    void open_connection()</span><br><span class="line">    &#123;</span><br><span class="line">        connection&#x3D;connection_managger.open(connection_details);</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line">    X(connection_info const&amp; connection_details_)</span><br><span class="line">    : connection_details(connection_details_)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    void send_data(data_packet const&amp; data)</span><br><span class="line">    &#123;</span><br><span class="line">        std::call_once(connection_init_flag, &amp;X::open_connection, this);</span><br><span class="line">        connection.send_data(data);   </span><br><span class="line">    &#125;</span><br><span class="line">    data_packet receive_data()</span><br><span class="line">    &#123;</span><br><span class="line">        std::call_once(connection_init_flag, &amp;X::open_connection, this);</span><br><span class="line">        return connection.receive_data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="保护很少更新的数据结构">保护很少更新的数据结构</h3>
<p>有些数据结果很少进行更新但偶尔又需要更新，比如DNS条目。更新操作需要线程独占数据结构直到完成更新，一旦更新完成，多个线程又可以安全地并发访问。这时用std::mutex就会丧失在不进行修改数据时，并发读取数据结构的能力。这时可以选择<code>boost::shared_mutex</code>，和<code>boost::shared_lock&lt;boost::shared_mutex&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;boost&#x2F;thread&#x2F;shared_mutex.hpp&gt;</span><br><span class="line"></span><br><span class="line">class dns_entry;</span><br><span class="line"></span><br><span class="line">class dns_cache</span><br><span class="line">&#123;</span><br><span class="line">    std::map&lt;std::string, dns_entry&gt; entries;</span><br><span class="line">    mutable boost::shared_mutex entry_mutex;</span><br><span class="line">public:</span><br><span class="line">    dns_entry find_entry(std::string const&amp; domain) const</span><br><span class="line">    &#123;</span><br><span class="line">        boost::shared_lock&lt;boost::shared_mutex&gt; lk(entry_mutex);</span><br><span class="line">        std::map&lt;std::string, dns_entry&gt;::const_iterator const it &#x3D; entries.find(domain);</span><br><span class="line">        return (it &#x3D;&#x3D; entries.end()) ? dns_entry():it-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    void update_or_add_entry(std::string const&amp; domain, dns_entry const&amp; dns_details)</span><br><span class="line">    &#123;</span><br><span class="line">        std::lock_guard&lt;boost::shared_mutex&gt; lk(entry_mutex);</span><br><span class="line">        entries[domain]&#x3D;dns_details;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里<code>find_entry()</code>利用<code>boost::shared_lock&lt;&gt;</code>来进行共享，只读获取的保护。<code>update_or_add_entry()</code>利用<code>std::lock_guard&lt;&gt;</code>来提供表更新时的排他访问。</p>
<h3 id="递归锁">递归锁</h3>
<p><code>std::mutex</code>，当一个线程试图对它已经拥有的互斥量加锁时会导致未定义行为。但是，在一些情况下需要一个线程可以多次获取同一个互斥量，并不需要首先释放它。C++标准库提供了<code>std::recursive_mutex</code>，可以对同一线程上的单个实例多次加锁。但是需要互斥量在被其他线程加锁之前释放所有的锁，调用lock()三次，必须调用unlock()三次。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/05/ndt-registration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/05/ndt-registration/" class="post-title-link" itemprop="url">ndt-registration</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-05 23:28:23" itemprop="dateCreated datePublished" datetime="2020-01-05T23:28:23+00:00">2020-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Registration/" itemprop="url" rel="index"><span itemprop="name">Registration</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>NDT（正态分布变换）是一种将点云表面表示为正态分布函数，通过最大化点到目标点表面的概率来估计两个点云之间刚体变换的配准方法，与ICP类似，也需要迭代进行，不同之处在于ICP的代价函数是点到点（点到面）之间的距离，而NDT的代价函数是点在目标表面上的概率。</p>
<h2 id="原理">原理</h2>
<p>通过传感器得到的点云可以看作物体表面的空间采样点，表面可以用概率密度函数来表示，例如正态分布。算法首先将点云按体素划分，对于每个体素计算概率密度函数，如果是正态分布的话，需要计算的参数为体素内点的均值和方差。假设参考帧表面点是由D维正态随机过程产生，测量值<span class="math inline">\(\vec{x}\)</span>的概率为： <span class="math display">\[ 
p(\vec{x}) = \frac{1}{(2\pi)^{D/2}\sqrt{|\Sigma|}}exp \left(-\frac{(\vec{x} - \vec{\mu})^T\Sigma^{-1}(\vec{x} - \vec{\mu})}{2}\right) \tag{6.1} 
\]</span> 均值和方差为： <span class="math display">\[
\vec\mu = \frac{1}{m}\sum_{k=1}^{m}\vec{y}_k \tag{6.2}
\]</span> <span class="math display">\[
\Sigma = \frac{1}{m-1}\sum_{k=1}^{m}(\vec{y}_k - \vec{\mu})(\vec{y}_k - \vec{\mu})^T \tag{6.3}
\]</span></p>
<p>NDT配准的目标是找到当前帧的位姿能够最大化当前帧的点在参考帧表面上的概率。优化的参数是位姿<span class="math inline">\(\vec{p}\)</span>, 当最大化似然概率时得到最佳的位姿参数。 <span class="math display">\[
\Psi = \prod_{k=1}^np(T(\vec{p},\vec{x}_k)) \tag{6.5}
\]</span> 等同于最小化负对数概率 <span class="math display">\[
-\log\Psi = -\sum_{k=1}^{n}\log\left(p(T(\vec{p},\vec{x}_k))\right) \tag{6.6}
\]</span> NDT混合采用了正态分布和均匀分布 <span class="math display">\[
\vec{p}(\vec{x}) = c_1\exp\left(-\frac{(\vec{x}-\vec{\mu})^T\Sigma^{-1}(\vec{x}-\vec{\mu})}{2} +  c_2p_0\right) \tag{6.7}
\]</span> 对于像 <span class="math inline">\(\bar{p}(x) = -\log(c_1\exp(-x^2/(2\sigma^2)) + c_2)\)</span> 这样的对数似然函数可以用高斯函数近似 <span class="math inline">\(\bar{p}(x) = d_1 \exp(-d_2x^2/(2\sigma^2)) + d_3\)</span>。 当 <span class="math inline">\(x = 0, \sigma, \infty\)</span> 时，可以计算得到 <span class="math inline">\(d_3, d_1, d_2\)</span>： <span class="math display">\[
\begin{array}{l}d_3 = -\log(c_2) \\
d_1 = -\log(c_1 + c_2) - d_3 \\
d_2 = -2\log((-log(c_1\exp(-1/2) + c_2) - d_3)/d_1)\end{array} \tag{6.8}
\]</span> 点在目标点云表面上的概率为： <span class="math display">\[
\bar{p}(x) = -d_1 \exp\left(-\frac{d_2}{2}(\vec{x} - \vec{\mu})^T\Sigma^{-1}(\vec{x} - \vec{\mu})\right) \tag{6.9}
\]</span></p>
<p>参数向量的评价函数为： <span class="math display">\[
s(\vec{p}) =  \sum_{k=1}^n\bar{p}\left(T(\vec{p},\vec{x}_k)\right) \tag{6.10}
\]</span></p>
<p>令<span class="math inline">\(\vec{x}_k^{‘} = T(\vec{p},\vec{x}_k) - \vec{\mu}_k\)</span>,评价函数的梯度向量和黑塞矩阵为： <span class="math display">\[
g_i = \frac{\delta{s}}{\delta{p}_i} = \sum_{k=1}^nd_1d_2\vec{x}_k^{&#39;T}\Sigma_k^{-1}\frac{\delta{s}}{\delta{p}}\exp(\frac{-d_2}{2}\vec{x}_k^{&#39;T}\Sigma_k^{-1}\vec{x}_k^{&#39;} \tag{6.12}
\]</span></p>
<p><span class="math display">\[
H_{ij} = \frac{\delta^2s}{\delta{p_i}\delta{p_j}} = \\
\sum_{k=1}^nd_1d_2\exp(\frac{-d_2}{2}\vec{x}_k^{&#39;T}\Sigma_k^{-1}\vec{x}_k^{&#39;})\left(-d_2(\vec{x}_k^{&#39;T}\Sigma_k^{-1}\frac{\delta\vec{x}_k^{&#39;}}{\delta{p_i}})(\vec{x}_k^{&#39;T}\Sigma_k^{-1}\frac{\delta\vec{x}_k^{&#39;}}{\delta{p_j}}) + \\ 
\vec{x}_k^{&#39;T}\Sigma_k^{-1}\frac{\delta^2\vec{x}_k^{&#39;}}{\delta{p_i}\delta{p_j}} + \\ 
{\frac{\delta\vec{x}_k^{&#39;}}{\delta{p_j}}^T}\Sigma_k^{-1}\frac{\delta\vec{x}_k^{&#39;}}{\delta{p_i}}\right) \tag{6.13}
\]</span></p>
<p>我们可以使用牛顿法来优化参数向量<span class="math inline">\(\vec{p}\)</span>，通过迭代求解方程<span class="math inline">\(H\Delta\vec{p} = -\vec{g}\)</span>得到更新的参数增量<span class="math inline">\(\Delta\vec{p}\)</span>，然后更新参数向量： <span class="math display">\[
\vec{p} = \vec{p} + \Delta\vec{p} * a
\]</span> 这里<span class="math inline">\(a\)</span>为步长，可通过线搜索方式确定或者默认设置为1。 NDT算法流程如下图所示： <img src="/2020/01/05/ndt-registration/ndt_pseudocode.png" class="" title="ndt-pipeline"></p>
<h2 id="d-ndt">3D NDT</h2>
<p>对于3D NDT算法，参数向量为六维向量，包含三个平移、三个旋转，若用欧拉角表示旋转： <span class="math display">\[
\vec{p}_6 = {[t_x,t_y,t_z,\phi_x,\phi_y,\phi_z]}^T
\]</span> 采用z-y-x的欧拉角顺序，3D变换方程为： <span class="math display">\[
\begin{aligned}
T_E(\vec{p_6},\vec{x}) &amp;=R_xR_yR_z\vec{x} + \vec{t} \\
 &amp;= \begin{bmatrix} c_yc_z &amp; -c_ys_z &amp; s_y \\
c_xs_z + s_xs_ys_z &amp; c_xc_z - s_xs_ys_z &amp; -s_xc_y \\
s_xs_z - c_xs_yc_z &amp; c_xs_ys_z + s_xc_z &amp; c_xc_y \\ \end{bmatrix}
+ \begin{bmatrix}t_x \\ t_y \\ t_z \end{bmatrix}\\
\end{aligned} \tag{6.17}
\]</span></p>
<p>雅克比矩阵为： <span class="math display">\[
J_E = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; c &amp; f \\
0 &amp; 1 &amp; 0 &amp; a &amp; d &amp; g \\
0 &amp; 0 &amp; 1 &amp; b &amp; e &amp; h \\
 \end{pmatrix} \tag{6.18}
\]</span></p>
<p>这里：</p>
<p><span class="math display">\[
\begin{aligned}
a &amp;= x_1(-s_xs_z+c_xs_yc_z) + x_2(-s_xc_z-c_xs_ys_z)+x_3(-c_xc_y)\\
b &amp;= x_1(c_xs_z+s_xs_ys_z)+x_2(-s_xs_ys_z+c_xc_z) + x_3(-s_xc_y)\\
c &amp;= x_1(-s_yc_z)+x_2(s_ys_z)+x_3(c_y)\\
d &amp;= x_1(s_xc_yc_z)+x_2(-s_xc_ys_z) + x_3(s_xs_y)\\
e &amp;= x_1(-c_xc_yc_z)+x_2(c_xc_ys_z) + x_3(-c_xs_y)\\
f &amp;= x_1(-c_ys_z)+x_2(-c_yc_z)\\
g &amp;= x_1(c_xc_z-s_xs_ys_z)+x_2(-c_xs_z-s_xs_yc_z)\\
h &amp;= x_1(s_xc_z+c_xs_ys_z)+x_2(c_xs_yc_z-s_xs_z)\\
\end{aligned} \tag{6.19}
\]</span></p>
<p>二阶梯度矩阵是一个18x6的矩阵： <span class="math display">\[
H_E = \begin{bmatrix}
\vec{H}_{11} &amp; \cdots &amp; \vec{H}_{16} \\
\vdots &amp; \ddots &amp; \vdots \\
\vec{H}_{61} &amp; \cdots &amp; \vec{H}_{66}
\end{bmatrix} = \begin{bmatrix}
\vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} \\
\vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} \\
\vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{0} \\
\vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{a} &amp; \vec{b} &amp; \vec{c} \\
\vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{b} &amp; \vec{d} &amp; \vec{e} \\
\vec{0} &amp; \vec{0} &amp; \vec{0} &amp; \vec{c} &amp; \vec{e} &amp; \vec{f} \\
\end{bmatrix} \tag{6.20}
\]</span></p>
这里： $$
<span class="math display">\[\begin{aligned}
\vec{a} &amp;= \begin{bmatrix} 0 \\x_1(-c_xs_z-s_xs_yc_z)+x_2(-c_xc_z+s_xs_ys_z)+x_3(s_xc_y) \\ x_1(-s_xs_z+c_xs_yc_z)+x_2(-c_xs_ys_z)+x_3(-c_xc_y)  \end{bmatrix} \\

\vec{b} &amp;= \begin{bmatrix}0 \\ x_1(c_xc_yc_z)+x_2(-c_xc_yc_z)+x_3(c_xs_y)\\ x_1(s_xc_yc_z)+x_2(-s_xc_ys_z)+x_3(s_xs_y)\\ \end{bmatrix}\\

\vec{c} &amp;= \begin{bmatrix}0 \\ x_1(-s_xc_z-c_xs_ys_z)+x_2(-s_xs_z-c_xs_yc_z) \\x_1(c_xc_z-s_xs_ys_z)+x_2(-s_xs_yc_z-c_xs_z) \end{bmatrix} \\

\vec{d} &amp;= \begin{bmatrix}x_1(-c_yc_z)+x_2(c_ys_z)+x_3(-s_y) \\ x_1(-s_xs_yc_z)+x_2(s_xs_ys_z)+x_3(s_xc_y) \\x_1(c_xs_yc_z)+x_2(-c_xs_ys_z)+x_3(-c_xc_y) \\ \end{bmatrix} \\

\vec{e} &amp;= \begin{bmatrix}x_1(s_ys_z)+x_2(s_yc_z)\\x_1(-s_xc_ys_z)+x_2(-s_xc_yc_z)\\ x_1(c_xc_ys_z)+x_2(c_xc_yc_z)\\ \end{bmatrix} \\

\vec{f} &amp;= \begin{bmatrix}x_1(-c_yc_z)+x_2(c_ys_z) \\x_1(-c_xs_z-s_xs_yc_z)+x_2(-c_xc_z+s_xs_ys_z)\\ x_1(-s_xs_z+c_xs_yc_z)+x_2(-c_xs_ys_z-s_xc_z)\\ \end{bmatrix} \\
\end{aligned} \tag{6.21}\]</span>
<p>$$</p>
<h2 id="实验">实验</h2>
<p>PCL里实现了ndt算法，另外还用了线搜索方法寻找步长，原理可参考文献[2][3],从用模拟数据和实际数据测试结果来看，NDT整体的效果还是比较不错的，不过耗时上并没有比ICP有太大优势，NDT也需要搜索临近的体素进行迭代优化。模拟的立方体边长10m, 点云大小为9602，体素大小为0.25m，真实位姿为（1.0，,1.0,1.0,0.1,0.2，,0.2）给定初始位姿为单位阵，ndt经过18次迭代收敛，耗时0.652s。<img src="/2020/01/05/ndt-registration/ndt_cube_init.png" class="" title="ndt-init"> <img src="/2020/01/05/ndt-registration/ndt_cube_final.png" class="" title="ndt-final"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/15/ceres-solving-non-linear-least-squares/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/15/ceres-solving-non-linear-least-squares/" class="post-title-link" itemprop="url">ceres-Solving non-linear least squares problem</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-15 09:40:21" itemprop="dateCreated datePublished" datetime="2019-09-15T09:40:21+00:00">2019-09-15</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="非线性最小二乘问题求解">非线性最小二乘问题求解</h2>
<h3 id="引言">引言</h3>
<p>有效使用Ceres需要熟悉非线性最小二乘求解器的一些基础组成部分，所以在描述怎么配置和使用求解器之前，先来简单看一下Ceres中的一些核心优化算法是如何工作的。</p>
<p>令 <span class="math inline">\(x \in \mathbb{R}^n\)</span> 是变量的一个 <span class="math inline">\(n\)</span> 维向量， <span class="math inline">\(F(x) = \left[f_1(x), ... , f_{m}(x) \right]^{\top}\)</span> 是 <span class="math inline">\(x\)</span> 的 <span class="math inline">\(m\)</span> 维函数。优化问题描述如下： <span class="math display">\[ 
\begin{split}\arg \min_x \frac{1}{2}\|F(x)\|^2  \\
L \le x \le U\end{split}  \tag{1}
\]</span><br />
这里， <span class="math inline">\(L\)</span> 和 <span class="math inline">\(U\)</span> 是参数向量 <span class="math inline">\(x\)</span> 的上下边界。</p>
<p>由于对于一般的 <span class="math inline">\(F(x)\)</span> ，很难有有效的全局最小化方法，一般通过寻找局部最小化来解决。 <span class="math inline">\(F(x)\)</span> 的雅可比矩阵 <span class="math inline">\(J(x)\)</span> 是一个 <span class="math inline">\(m \times n\)</span> 的矩阵。这里， <span class="math inline">\(J_{ij}(x) = \partial_j f_i(x)\)</span> ，梯度向量为 <span class="math inline">\(g(x) = \nabla \frac{1}{2}\|F(x)\|^2 = J(x)^\top F(x)\)</span>。</p>
<p>解决非线性优化问题的一般策略是通过解决原始问题的一系列近似。在一次迭代中，求解近似来得到向量 <span class="math inline">\(x\)</span> 的一个校正量 <span class="math inline">\(\Delta x\)</span>，对于非线性最小二乘，通过线性化来构造近似 <span class="math inline">\(F(x+\Delta x) \approx F(x) + J(x)\Delta x\)</span>，这就得到了下边的线性最小二乘问题：</p>
<p><span class="math display">\[
 \min_{\Delta x} \frac{1}{2}\|J(x)\Delta x + F(x)\|^2\quad(2)
 \]</span> 不幸的是，简单地求解一系列这些问题并更新 <span class="math inline">\(x \leftarrow x+ \Delta x\)</span> 会导致算法不收敛。为了得到一个收敛的算法，我们需要控制步长 <span class="math inline">\(\Delta x\)</span> 的大小。 根据如何控制步长 <span class="math inline">\(\Delta x\)</span> 的大小，非线性优化算法可以分为两大类： 1. <strong>信赖域（Trust Region)</strong> 信赖域方法在搜索空间（称为信赖域）的一个子集上利用模型函数来近似目标函数，如果模型函数成功地最小化真正地目标函数，信赖域就会扩大，反之缩小，再次求解模型优化问题。 2. <strong>线搜索（Line Search)</strong> 线搜索方法首先找到目标函数减少的下降方向，然后计算决定朝下降方向移动移动的步长大小。下降方向可以由多种方法计算，例如梯度下降法， Newton's method 和 Quasi-Newton 方法。</p>
<p>信赖域方法首先选择一个步长大小然后是步长方向，而线搜索方法首先选择步长方向然后是步长大小。</p>
<h3 id="信赖域方法">信赖域方法</h3>
<p>基本的信赖域方法流程如下： 1. 给定一个初始点 <span class="math inline">\(x\)</span> 和 一个信赖域半径 <span class="math inline">\(\mu\)</span> 。 2. 求解 <span class="math display">\[\begin{split}\arg \min_{\Delta x}&amp; \frac{1}{2}\|J(x)\Delta x + F(x)\|^2 \\ \text{such that} &amp;\|D(x)\Delta x\|^2 \le \mu\\
     &amp;L \le x + \Delta x \le U.\end{split}
     \]</span> 3. <span class="math display">\[
      \rho = \frac{\displaystyle \|F(x + \Delta x)\|^2 -
       \|F(x)\|^2}{\displaystyle \|J(x)\Delta x + F(x)\|^2 -
       \|F(x)\|^2}
      \]</span> 4. 如果 <span class="math inline">\(\rho &gt; \epsilon\)</span> 则 <span class="math inline">\(x = x + \Delta x\)</span> 5. 如果 <span class="math inline">\(\rho &gt; \eta_1\)</span> 则 <span class="math inline">\(\mu = 2\mu\)</span> 6. 如果 <span class="math inline">\(\rho &lt; \eta_2\)</span> 则 <span class="math inline">\(\mu = 0.5 * \mu\)</span> 7. 返回第二步 这里，<span class="math inline">\(\mu\)</span> 是信赖域半径， <span class="math inline">\(D(x)\)</span> 矩阵定义了 <span class="math inline">\(F(x)\)</span> 域上的度量。<span class="math inline">\(\rho\)</span> 测量步长 <span class="math inline">\(\Delta x\)</span> 的质量，例如，线性模型在非线性目标值里预测下降有多好。通过线性化预测非线性目标的行为有多好来决定增大或减小信赖域的范围。</p>
<p>信赖域方法的关键步骤求解带约束的优化问题 <span class="math display">\[
\begin{split}\arg \min_{\Delta x}&amp;\quad \frac{1}{2}\|J(x)\Delta x + F(x)\|^2 \\
\text{such that} &amp;\quad \|D(x)\Delta x\|^2 \le \mu\\
 &amp;\quad L \le x + \Delta x \le U.\end{split}\quad (3)
\]</span> Ceres实现了两种信赖域方法：Levenberg-Marquardt 和 Dogleg。</p>
<p>#### Levenberg-Marquardt Levenberg-Marquardt 是求解非线性最小二乘问题的最流行的算法。求解问题（3）可以通过求解下边形式的无约束优化问题： <span class="math display">\[\arg\min_{\Delta x} \frac{1}{2}\|J(x)\Delta x + F(x)\|^2 +\lambda  \|D(x)\Delta x\|^2\]</span> 这里， <span class="math inline">\(\lambda\)</span> 是拉格朗日乘数是 <span class="math inline">\(\mu\)</span>的逆，在Ceres中， 求解： <span class="math display">\[\arg\min_{\Delta x} \frac{1}{2}\|J(x)\Delta x + F(x)\|^2 + \frac{1}{\mu} \|D(x)\Delta x\|^2\quad(4)\]</span> 矩阵 <span class="math inline">\(D(x)\)</span> 是一个非负对角阵， 通常是 <span class="math inline">\(J(x)^\top J(x)\)</span> 的对角阵的平方根。</p>
<p>在进行下一步之前，我们先简化一些表示。假设矩阵 <span class="math inline">\(\frac{1}{\sqrt{\mu}} D\)</span> 已经添加到矩阵 <span class="math inline">\(J\)</span> 的底部，相似的，零向量也被添加到向量 <span class="math inline">\(f\)</span> 的底部。 下边的讨论将使用 <span class="math inline">\(J\)</span> 和 <span class="math inline">\(f\)</span> ： <span class="math display">\[\min_{\Delta x} \frac{1}{2} \|J(x)\Delta x + f(x)\|^2 \quad (5)\]</span> Ceres提供两类方法来解决问题（5）- 分解和迭代。</p>
<p>分解法利用Cholesky 和 QR 分解来计算精确解。但是不清楚问题（4）的精确解在求解问题（1）时LM算法的的每一步是否是必须的。</p>
<p>不精确的牛顿法需要两部分。首先，一种近似求解线性方程组的廉价方法。例如，像Conjugate Gradients方法这样的迭代线性求解器。 第二，迭代求解器的终止规则。 典型的终止规则是下边的形式： <span class="math display">\[\|H(x) \Delta x + g(x)\| \leq \eta_k \|g(x)\|\quad(6)\]</span> 这里，<span class="math inline">\(k\)</span> 表示LM迭代次数。</p>
<h4 id="dogleg">Dogleg</h4>
<p>另外一种求解信赖域问题的策略由M.J.D.Powell引入。关键思想是计算两个向量： <span class="math display">\[\begin{split}\Delta x^{\text{Gauss-Newton}} &amp;= \arg \min_{\Delta x}\frac{1}{2} \|J(x)\Delta x + f(x)\|^2.\\
\Delta x^{\text{Cauchy}} &amp;= -\frac{\|g(x)\|^2}{\|J(x)g(x)\|^2}g(x).\end{split}\]</span> 注意向量 <span class="math inline">\(\Delta x^{\text{Gauss-Newton}}\)</span> 是问题（2）的解，<span class="math inline">\(\Delta x^{\text{Cauchy}}\)</span> 是最小化线性近似的向量如果我们限制朝着梯度方向移动。Dogleg方法寻找由 <span class="math inline">\(\Delta x^{\text{Gauss-Newton}}\)</span> 定义的向量 <span class="math inline">\(\Delta x\)</span> 和 <span class="math inline">\(\Delta x^{\text{Cauchy}}\)</span> 来解决信赖域问题。</p>
<h4 id="inner-iterations">Inner Iterations</h4>
<p>一些非线性最小二乘问题在参数块相互作用的方式上有额外的结构，这有利于改变信赖域步骤计算的方式。例如，考虑下边的回归问题： <span class="math display">\[y = a_1 e^{b_1 x} + a_2 e^{b_3 x^2 + c_1}\]</span> 给定一个 <span class="math inline">\(\{(x_i, y_i)\}\)</span> 的集合，用户想要估计 <span class="math inline">\(a_1, a_2, b_1, b_2\)</span> 和 <span class="math inline">\(c_1\)</span> 。</p>
<p>注意到表达式左边在<span class="math inline">\(a_1\)</span> 和 <span class="math inline">\(a_2\)</span> 上是线性的，给定任意的 <span class="math inline">\(b_1, b_2, c_1\)</span> ，可以用线性回归来估计 <span class="math inline">\(a_1\)</span> 和 <span class="math inline">\(a_2\)</span> 的最优值，从问题中完全解析地消除变量 <span class="math inline">\(a_1\)</span> 和 <span class="math inline">\(a_2\)</span> 是可能地。 像这样地问题称为可分离地最小二乘问题，求解这类问题最有名的算法是由Golub和Pereyra提出的Variable Projection 算法。 相似的结构可以在带有丢失数据问题的矩阵分解中找到，相应的算法叫做Wiberg's算法。</p>
<p>将<code>Solver::Options::use_inner_iterations</code>设置为<code>true</code>可以启用Ruhe&amp;Wedin's Algorithm II。Ceres版本具有更高的迭代复杂度，但是每次迭代中也会更好地收敛。</p>
<h4 id="non-monotonic-steps">Non-monotonic Steps</h4>
<p>注意上述的信赖域方法是一个下降算法只接受使目标函数值严格减少的点。放宽这个条件可以使算法在长期内更有效，代价是目标函数的值会在局部增大。这是因为允许非下降的目标函数值可以使算法跳过巨石，因为该方法不限于移动到窄谷中同时保持其收敛特性。</p>
<p>将<code>Solver::Options::use_nonmonotonic_steps</code>设置为<code>true</code>可以启用非单调信赖域算法。</p>
<h3 id="line-search-method">Line Search Method</h3>
<p>Ceres中的线搜索方法目前还不能处理边界约束，所以只可以用来求解无约束问题。线搜索算法步骤如下： 1. 给定一个初始点 <span class="math inline">\(x\)</span> 2. <span class="math inline">\(\Delta x = -H^{-1}(x) g(x)\)</span> 3. <span class="math inline">\(\arg \min_\mu \frac{1}{2} \| F(x + \mu \Delta x) \|^2\)</span> 4. <span class="math inline">\(x = x + \mu \Delta x\)</span> 5. 返回到步骤2 这里 <span class="math inline">\(H(x)\)</span> 使目标函数的黑塞矩阵的近似估计，<span class="math inline">\(g(x)\)</span> 是在 <span class="math inline">\(x\)</span> 处的梯度。根据 <span class="math inline">\(H(x)\)</span> 的选择，我们可以得到各种不同的搜索方向 <span class="math inline">\(\Delta x\)</span> 。目前，Ceres支持三种搜索方向。 1. <code>STEEPEST_DESCENT</code> 这对应于选择 <span class="math inline">\(H(x)\)</span> 为单位矩阵。除了对最简单的问题外，这不是一个好的搜索方向。 2. <code>NONLINEAR_CONJUGATE_GRADIENT</code> 共轭梯度法对非线性函数的一般化，可以以不同方式执行，导致不同的搜索方向。Ceres 目前支持 <code>FLETCHER_REEVES</code>，<code>POLAK_RIBIERE</code> 和 <code>HESTENES_STIEFEL</code> 方向。 3. <code>BFGS</code> Secant方法对多维的一般化，其中维持了逆黑塞矩阵的一个完全密集近似用于计算quasi-Newton 步骤 4. <code>LBFGS</code> <code>BFGS</code>的有限近似方法。</p>
<h3 id="linearsolver">LinearSolver</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/12/ceres-modeling-non-linear-least-squares/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/12/ceres-modeling-non-linear-least-squares/" class="post-title-link" itemprop="url">Ceres-Modeling Non-Linear Least Squares</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-12 20:57:53" itemprop="dateCreated datePublished" datetime="2019-05-12T20:57:53+00:00">2019-05-12</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="用ceres解决非线性最小二乘问题">用ceres解决非线性最小二乘问题</h2>
<p>google的开源优化库ceres可以用来解决稳健的边界约束非线性最小二乘问题，形式如下： <span class="math display">\[\min_x \frac{1}{2}\sum_{i}\rho_i({||f_i(x_{i1},\cdots,x_{ik})||}^2)\]</span> <span class="math display">\[ s.t. l_j \leq x_j \leq u_j\]</span> 在ceres中，表达式 <span class="math inline">\(\rho_i({||f_i(x_{i1},\cdots,x_{ik})||}^2)\)</span> 称作残差块(residual block)， <span class="math inline">\(f_i(\cdot)\)</span> 是代价函数(<code>CostFunction</code>)， <span class="math inline">\({x_{i1},\cdots,x_{ik}}\)</span> 为参数块(parameter blocks)。<span class="math inline">\(\rho_i\)</span> 是损失函数(<code>LossFunction</code>)，损失函数是一个标量方程用来减少非线性最小二乘问题中局外点的影响，又称为核函数。<span class="math inline">\(l_j\)</span> 和 <span class="math inline">\(u_j\)</span> 是参数块 <span class="math inline">\(x_j\)</span> 的上下范围。<br />
特殊情况下，当 <span class="math inline">\(\rho_i(x) =x\)</span>，而且 <span class="math inline">\(l_j = -\infty\)</span> ， <span class="math inline">\(u_j = \infty\)</span> 就得到常见的无约束非线性最小二乘问题： <span class="math display">\[\frac12\sum_{i}{||f_i(x_{i1},\cdots,x_{ik})||}^2\]</span></p>
<h3 id="代价函数">代价函数</h3>
<p>对于目标函数的每一项，代价函数用来计算残差向量和雅可比矩阵，具体来说，考虑函数 <span class="math inline">\(f(x_1,\cdots,x_k)\)</span>，其参数块为 <span class="math inline">\([x_1,\cdots,x_k]\)</span>。给定参数块 <span class="math inline">\([x_1,\cdots,x_k]\)</span> ，代价函数负责计算残差向量 <span class="math inline">\(f(x_1,\cdots,x_k)\)</span> 和雅可比矩阵 <span class="math display">\[J_i =  \frac{\partial}{\partial x_i} f(x_1, ..., x_k) \quad \forall i \in \{1, \ldots, k\} \]</span> ceres 提供了多种代价函数，它们都派生与基类<code>CostFunction</code>，它有两个重要的成员变量<code>CostFunction::parameter_block_sizes_</code>和<code>CostFunction::num_residuals_</code>，分别表示参数块的大小和残差的个数。 #### SizedCostFunction 如果参数块的大小和残差向量的大小在编译时期是已知的，这时候就可以使用<code>SizedCostFunction</code>，参数通过模板参数指定，用户只需实现<code>CostFunction::Evaluate()</code>。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">template&lt;int kNumResiduals,</span><br><span class="line">         int N0 &#x3D; 0, int N1 &#x3D; 0, int N2 &#x3D; 0, int N3 &#x3D; 0, int N4 &#x3D; 0,</span><br><span class="line">         int N5 &#x3D; 0, int N6 &#x3D; 0, int N7 &#x3D; 0, int N8 &#x3D; 0, int N9 &#x3D; 0&gt;</span><br><span class="line">class SizedCostFunction : public CostFunction &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual bool Evaluate(double const* const* parameters,</span><br><span class="line">                        double* residuals,</span><br><span class="line">                        double** jacobians) const &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### AutoDiffCostFunction 定义一个<code>CostFunction</code>或<code>SizedCostFunction</code>是比较麻烦和容易出错的，尤其在计算导数的时候，Ceres提供了自动差分方法,是最常用的代价函数。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename CostFunctor,</span><br><span class="line">       int kNumResiduals,  &#x2F;&#x2F; Number of residuals, or ceres::DYNAMIC.</span><br><span class="line">       int N0,       &#x2F;&#x2F; Number of parameters in block 0.</span><br><span class="line">       int N1 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 1.</span><br><span class="line">       int N2 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 2.</span><br><span class="line">       int N3 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 3.</span><br><span class="line">       int N4 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 4.</span><br><span class="line">       int N5 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 5.</span><br><span class="line">       int N6 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 6.</span><br><span class="line">       int N7 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 7.</span><br><span class="line">       int N8 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 8.</span><br><span class="line">       int N9 &#x3D; 0&gt;   &#x2F;&#x2F; Number of parameters in block 9.</span><br><span class="line">class AutoDiffCostFunction : public</span><br><span class="line">SizedCostFunction&lt;kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9&gt; &#123;</span><br><span class="line"> public:</span><br><span class="line">  explicit AutoDiffCostFunction(CostFunctor* functor);</span><br><span class="line">  &#x2F;&#x2F; Ignore the template parameter kNumResiduals and use</span><br><span class="line">  &#x2F;&#x2F; num_residuals instead.</span><br><span class="line">  AutoDiffCostFunction(CostFunctor* functor, int num_residuals);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 为了得到一个自动差分代价函数，你必须定义一个带有模板操作符()的类（函数对象）作为模板参数<code>T</code>。为了计算导数，自动差分框架会在需要的时候为<code>T</code>替换合适的<code>Jet</code>对象，但这是隐藏的。这个函数必须把计算的值写入到最后一个参数中（唯一的非const参数）并返回<code>true</code>。<br />
例如，考虑一个标量误差 <span class="math inline">\(e = k - x^\top y\)</span>，<code>x</code>和<code>y</code>都是二维向量参数，<code>k</code>是一个常量。这种常量和表达式的差形式的误差是最小二乘问题中的常见模式。例如，<span class="math inline">\(x^\top y\)</span> 可能是一系列观测值的模型期望，对于每个观测值都有一个代价函数的实例。<br />
添加到最小二乘问题中的实际代价是 <span class="math inline">\(e^2\)</span> ，或者 <span class="math inline">\((k - x^\top y)^2\)</span>；平方向由优化框架隐式完成。 要写出上述模型的一个自动差分代价函数，首先定义个函数对象： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class MyScalarCostFunctor &#123;</span><br><span class="line">  MyScalarCostFunctor(double k): k_(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename T&gt;</span><br><span class="line">  bool operator()(const T* const x , const T* const y, T* e) const &#123;</span><br><span class="line">    e[0] &#x3D; k_ - x[0] * y[0] - x[1] * y[1];</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  double k_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 注意<code>operator()</code>的声明，首先是输入参数<code>x</code>和<code>y</code>,是一个指向类型为<code>T</code>的数组的常量指针。输出项总是最后一个参数，也是指向数组的指针，在上述例子中，<code>e</code>是一个标量，所以只有<code>e[0]</code>被赋值。<br />
定义了这个类后，自动差分代价函数可以按下边的方式构造： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CostFunction* cost_function</span><br><span class="line">    &#x3D; new AutoDiffCostFunction&lt;MyScalarCostFunctor, 1, 2, 2&gt;(</span><br><span class="line">        new MyScalarCostFunctor(1.0));              ^  ^  ^</span><br><span class="line">                                                    |  |  |</span><br><span class="line">                        Dimension of residual ------+  |  |</span><br><span class="line">                        Dimension of x ----------------+  |</span><br><span class="line">                        Dimension of y -------------------+</span><br></pre></td></tr></table></figure> 在这个例子中，每个测量值<code>k</code>都有一个实例。模板参数<code>MyScalarCostFunction,&lt;1,2,2&gt;</code>描述了函数对象从两个二维参数中计算一个一维输出。 <code>AutoDiffCostFunction</code>还支持运行时决定残差个数，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CostFunction* cost_function</span><br><span class="line">    &#x3D; new AutoDiffCostFunction&lt;MyScalarCostFunctor, DYNAMIC, 2, 2&gt;(</span><br><span class="line">        new CostFunctorWithDynamicNumResiduals(1.0),   ^     ^  ^</span><br><span class="line">        runtime_number_of_residuals); &lt;----+           |     |  |</span><br><span class="line">                                           |           |     |  |</span><br><span class="line">                                           |           |     |  |</span><br><span class="line">          Actual number of residuals ------+           |     |  |</span><br><span class="line">          Indicate dynamic number of residuals --------+     |  |</span><br><span class="line">          Dimension of x ------------------------------------+  |</span><br><span class="line">          Dimension of y ---------------------------------------+</span><br></pre></td></tr></table></figure> #### DynamicAutoDiffCostFunction <code>AutoDiffCostFunction</code>需要在编译期知道参数块的个数和大小。还有参数块数量的限制，最多十个。在许多应用中，这是不够的，例如，贝塞尔曲线拟合。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename CostFunctor, int Stride &#x3D; 4&gt;</span><br><span class="line">class DynamicAutoDiffCostFunction : public CostFunction &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 和<code>AutoDiffCostFunction</code>一样，用户必须定义一个模板函数对象，但是函数签名有些不同，形式如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct MyCostFunctor &#123;</span><br><span class="line">  template&lt;typename T&gt;</span><br><span class="line">  bool operator()(T const* const* parameters, T* residuals) const &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 由于参数的的大小是在运行时决定的，在创建动态差分代价函数之后你必须说明参数大小，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DynamicAutoDiffCostFunction&lt;MyCostFunctor, 4&gt;* cost_function &#x3D;</span><br><span class="line">  new DynamicAutoDiffCostFunction&lt;MyCostFunctor, 4&gt;(</span><br><span class="line">    new MyCostFunctor());</span><br><span class="line">cost_function-&gt;AddParameterBlock(5);</span><br><span class="line">cost_function-&gt;AddParameterBlock(10);</span><br><span class="line">cost_function-&gt;SetNumResiduals(21);</span><br></pre></td></tr></table></figure> #### NumericDiffCostFunction 在一些情况下，定义一个模板代价函数对象是不可能的，例如当评价残差涉及到调用你没有控制权的库函数。这种情况下，可以使用数值差分。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename CostFunctor,</span><br><span class="line">          NumericDiffMethodType method &#x3D; CENTRAL,</span><br><span class="line">          int kNumResiduals,  &#x2F;&#x2F; Number of residuals, or ceres::DYNAMIC.</span><br><span class="line">          int N0,       &#x2F;&#x2F; Number of parameters in block 0.</span><br><span class="line">          int N1 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 1.</span><br><span class="line">          int N2 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 2.</span><br><span class="line">          int N3 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 3.</span><br><span class="line">          int N4 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 4.</span><br><span class="line">          int N5 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 5.</span><br><span class="line">          int N6 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 6.</span><br><span class="line">          int N7 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 7.</span><br><span class="line">          int N8 &#x3D; 0,   &#x2F;&#x2F; Number of parameters in block 8.</span><br><span class="line">          int N9 &#x3D; 0&gt;   &#x2F;&#x2F; Number of parameters in block 9.</span><br><span class="line">class NumericDiffCostFunction : public</span><br><span class="line">SizedCostFunction&lt;kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9&gt; &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 对于一个标量误差 <span class="math inline">\(e = k - x&#39;y\)</span> 数值差分函数对象定义如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyScalarCostFunctor &#123;</span><br><span class="line">  MyScalarCostFunctor(double k): k_(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  bool operator()(const double* const x,</span><br><span class="line">                  const double* const y,</span><br><span class="line">                  double* residuals) const &#123;</span><br><span class="line">    residuals[0] &#x3D; k_ - x[0] * y[0] + x[1] * y[1];</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  double k_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 利用中心差分计算导数的数值差分代价函数可以如下构造： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CostFunction* cost_function</span><br><span class="line">    &#x3D; new NumericDiffCostFunction&lt;MyScalarCostFunctor, CENTRAL, 1, 2, 2&gt;(</span><br><span class="line">        new MyScalarCostFunctor(1.0));                    ^     ^  ^  ^</span><br><span class="line">                                                          |     |  |  |</span><br><span class="line">                              Finite Differencing Scheme -+     |  |  |</span><br><span class="line">                              Dimension of residual ------------+  |  |</span><br><span class="line">                              Dimension of x ----------------------+  |</span><br><span class="line">                              Dimension of y -------------------------+</span><br></pre></td></tr></table></figure> NumericDiffCostFunction也支持运行时决定残差大小。 #### DynamicNumericDiffCostFunction 对于<code>AutoDiffCostFunction</code>，<code>NumericDiffCostFunction</code>，需要在编译期知道参数块的个数和大小，只支持对多10个参数块，在许多情况下，这是不够的,这是可以使用<code>DynamicNumericDiffCostFunction</code>。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename CostFunctor, NumericDiffMethodType method &#x3D; CENTRAL&gt;</span><br><span class="line">class DynamicNumericDiffCostFunction : public CostFunction &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 像<code>NumericDiffCostFunction</code>一样，用户必须定义一个函数对象，但是函数签名有些不同。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct MyCostFunctor &#123;</span><br><span class="line">  bool operator()(double const* const* parameters, double* residuals) const &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 参数大小在运行时决定，在创建动态数值差分代价函数时你必须说明参数大小。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DynamicNumericDiffCostFunction&lt;MyCostFunctor&gt;* cost_function &#x3D;</span><br><span class="line">  new DynamicNumericDiffCostFunction&lt;MyCostFunctor&gt;(new MyCostFunctor);</span><br><span class="line">cost_function-&gt;AddParameterBlock(5);</span><br><span class="line">cost_function-&gt;AddParameterBlock(10);</span><br><span class="line">cost_function-&gt;SetNumResiduals(21);</span><br></pre></td></tr></table></figure> #### CostFunctionToFunctor <code>CostFunctionToFunctor</code> 是一个适配器类允许用户在模板函数对象中使用<code>CostFuntion</code>对象，模板函数用来自动差分。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class IntrinsicProjection : public SizedCostFunction&lt;2, 5, 3&gt; &#123;</span><br><span class="line">  public:</span><br><span class="line">    IntrinsicProjection(const double* observation);</span><br><span class="line">    virtual bool Evaluate(double const* const* parameters,</span><br><span class="line">                          double* residuals,</span><br><span class="line">                          double** jacobians) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 是一个<code>CostFunction</code>实现一个在局部坐标系下的点到它的像平面的投影并从观测点投影减去它。可以计算它的残差或者通过解析或数值差分计算其雅可比。 现在我们想将这个<code>CostFunction</code>和相机外参组合起来。假设我们由一个模板函数 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void RotateAndTranslatePoint(const T* rotation,</span><br><span class="line">                             const T* translation,</span><br><span class="line">                             const T* point,</span><br><span class="line">                             T* result);</span><br></pre></td></tr></table></figure> 我们可以像下面这样做： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct CameraProjection &#123;</span><br><span class="line">  CameraProjection(double* observation)</span><br><span class="line">  : intrinsic_projection_(new IntrinsicProjection(observation)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename T&gt;</span><br><span class="line">  bool operator()(const T* rotation,</span><br><span class="line">                  const T* translation,</span><br><span class="line">                  const T* intrinsics,</span><br><span class="line">                  const T* point,</span><br><span class="line">                  T* residual) const &#123;</span><br><span class="line">    T transformed_point[3];</span><br><span class="line">    RotateAndTranslatePoint(rotation, translation, point, transformed_point);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Note that we call intrinsic_projection_, just like it was</span><br><span class="line">    &#x2F;&#x2F; any other templated functor.</span><br><span class="line">    return intrinsic_projection_(intrinsics, transformed_point, residual);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  CostFunctionToFunctor&lt;2,5,3&gt; intrinsic_projection_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 注意<code>CostFunctionToFunctor</code>在构造函数里获得了<code>CostFunction</code>的所有权。 在上边的例子中，我们假定<code>IntrinsicProjection</code>是一个<code>CostFunction</code>，能够评价它的值和导数。如果不是这样，<code>IntrinsicProjection</code>定义如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct IntrinsicProjection</span><br><span class="line">  IntrinsicProjection(const double* observation) &#123;</span><br><span class="line">    observation_[0] &#x3D; observation[0];</span><br><span class="line">    observation_[1] &#x3D; observation[1];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool operator()(const double* calibration,</span><br><span class="line">                  const double* point,</span><br><span class="line">                  double* residuals) &#123;</span><br><span class="line">    double projection[2];</span><br><span class="line">    ThirdPartyProjectionFunction(calibration, point, projection);</span><br><span class="line">    residuals[0] &#x3D; observation_[0] - projection[0];</span><br><span class="line">    residuals[1] &#x3D; observation_[1] - projection[1];</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"> double observation_[2];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 这里<code>ThirdPartyProjectionFunction</code>是我们不能控制的第三方库函数。所以这个函数可以计算它的值，我们想用数值差分来计算它的导数，这种情况下，我们使用<code>NumericDiffCostFunction</code>和<code>CostFunctionToFunctor</code>来完成这项工作。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct CameraProjection &#123;</span><br><span class="line">  CameraProjection(double* observation)</span><br><span class="line">    intrinsic_projection_(</span><br><span class="line">      new NumericDiffCostFunction&lt;IntrinsicProjection, CENTRAL, 2, 5, 3&gt;(</span><br><span class="line">        new IntrinsicProjection(observation)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename T&gt;</span><br><span class="line">  bool operator()(const T* rotation,</span><br><span class="line">                  const T* translation,</span><br><span class="line">                  const T* intrinsics,</span><br><span class="line">                  const T* point,</span><br><span class="line">                  T* residuals) const &#123;</span><br><span class="line">    T transformed_point[3];</span><br><span class="line">    RotateAndTranslatePoint(rotation, translation, point, transformed_point);</span><br><span class="line">    return intrinsic_projection_(intrinsics, transformed_point, residual);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  CostFunctionToFunctor&lt;2,5,3&gt; intrinsic_projection_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> #### DynamicCostFunctionToFunctor <code>DynamicCostFunctionToFunctor</code>提供<code>CostFunctionToFunctor</code>一样的功能，对于参数向量和残差的个数和大小在编译期未知的情况。模板函数对象的形式如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">bool operator()(T const* const* parameters, T* residuals) const;</span><br></pre></td></tr></table></figure> 和<code>CostFunctionToFunctor</code>给出的例子一样，我们假设： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class IntrinsicProjection : public CostFunction &#123;</span><br><span class="line">  public:</span><br><span class="line">    IntrinsicProjection(const double* observation);</span><br><span class="line">    virtual bool Evaluate(double const* const* parameters,</span><br><span class="line">                          double* residuals,</span><br><span class="line">                          double** jacobians) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 是一个<code>CostFunction</code>实现一个在局部坐标系下的点到它的像平面的投影并从观测点投影减去它。将这个<code>CostFunction</code>用在模板函数对象里形式如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct CameraProjection &#123;</span><br><span class="line">  CameraProjection(double* observation)</span><br><span class="line">      : intrinsic_projection_(new IntrinsicProjection(observation)) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  template &lt;typename T&gt;</span><br><span class="line">  bool operator()(T const* const* parameters,</span><br><span class="line">                  T* residual) const &#123;</span><br><span class="line">    const T* rotation &#x3D; parameters[0];</span><br><span class="line">    const T* translation &#x3D; parameters[1];</span><br><span class="line">    const T* intrinsics &#x3D; parameters[2];</span><br><span class="line">    const T* point &#x3D; parameters[3];</span><br><span class="line"></span><br><span class="line">    T transformed_point[3];</span><br><span class="line">    RotateAndTranslatePoint(rotation, translation, point, transformed_point);</span><br><span class="line"></span><br><span class="line">    const T* projection_parameters[2];</span><br><span class="line">    projection_parameters[0] &#x3D; intrinsics;</span><br><span class="line">    projection_parameters[1] &#x3D; transformed_point;</span><br><span class="line">    return intrinsic_projection_(projection_parameters, residual);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> private:</span><br><span class="line">  DynamicCostFunctionToFunctor intrinsic_projection_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 像<code>CostFunctionToFunctor</code>一样，<code>DynamicCostFunctionToFunctor</code>在构造函数里获得了<code>CostFunction</code>的所有权。 #### ConditionedCostFunction 这个类允许你对一个封装的代价函数的残差值应用不同的条件。比如说，你有一个代价函数可以得到N个值，但是你想总的代价不是所有这些值的平方和，可能你想对某些值应用不同的尺度，来改变它们对代价的贡献程度。 用法： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;  my_cost_function produces N residuals</span><br><span class="line">CostFunction* my_cost_function &#x3D; ...</span><br><span class="line">CHECK_EQ(N, my_cost_function-&gt;num_residuals());</span><br><span class="line">vector&lt;CostFunction*&gt; conditioners;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;  Make N 1x1 cost functions (1 parameter, 1 residual)</span><br><span class="line">CostFunction* f_1 &#x3D; ...</span><br><span class="line">conditioners.push_back(f_1);</span><br><span class="line"></span><br><span class="line">CostFunction* f_N &#x3D; ...</span><br><span class="line">conditioners.push_back(f_N);</span><br><span class="line">ConditionedCostFunction* ccf &#x3D;</span><br><span class="line">  new ConditionedCostFunction(my_cost_function, conditioners);</span><br></pre></td></tr></table></figure> ## 损失函数 对于最小二乘问题，最小化可能会遇到输入项包含外点的情况（完全错误的测量），这时就需要损失函数来减少它们的影响。<br />
考虑一个SFM问题，未知项是3D点和相机参数，测量是图像坐标，描述的是相机坐标系下三维点的重投影位置。例如，我们想要建模具有消防栓和车辆的街道场景的几何结构，由一个不知道参数的运动相机观测。我们关心的3D点是消防栓的顶点，图像处理算法负责得到输入到ceres的测量值，可以得到顶点在所有图像帧的观测和匹配情况，但是有一帧把汽车上的点错误当成了消防栓上的点。如果我们不对这个特殊的残差做任何处理，这个错误观测将会导致结果偏离最优。<br />
利用一个稳健的损失函数，可以减少较大残差的代价，外点项的权重较小就不会过多影响最终结果。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LossFunction &#123;</span><br><span class="line"> public:</span><br><span class="line">  virtual void Evaluate(double s, double out[3]) const &#x3D; 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 关键方法是<code>LossFunction::Evaluate()</code>，输入是一个非负标量<code>s</code>，计算一个<code>out</code>， <span class="math display">\[out = \begin{bmatrix}\rho(s), &amp; \rho&#39;(s), &amp; \rho&#39;&#39;(s)\end{bmatrix}\]</span> 这里每项对代价函数的贡献由 <span class="math inline">\(\frac{1}{2}\rho(s)\)</span> 给出，<span class="math inline">\(s = \|f_i\|^2\)</span>。<br />
最合理的 <span class="math inline">\(\rho\)</span>满足： <span class="math display">\[\begin{split}\rho(0) &amp;= 0\\
\rho&#39;(0) &amp;= 1\\
\rho&#39;(s) &amp;&lt; 1 \text{ in the outlier region}\\
\rho&#39;&#39;(s) &amp;&lt; 0 \text{ in the outlier region}\end{split}\]</span></p>
<h2 id="理论">理论</h2>
<p>让我们考虑具有一个参数块的最小二乘问题。 <span class="math display">\[\min_x \frac{1}{2}\rho(f^2(x))\]</span> 稳健的梯度和高斯牛顿黑塞矩阵为： <span class="math display">\[\begin{split}g(x) &amp;= \rho&#39;J^\top(x)f(x)\\
H(x) &amp;= J^\top(x)\left(\rho&#39; + 2 \rho&#39;&#39;f(x)f^\top(x)\right)J(x)\end{split}\]</span> 这里忽略了<span class="math inline">\(f(x)\)</span> 的二阶梯度。注意如果 <span class="math inline">\(\rho&#39;&#39;f(x)^\top f(x) + \frac{1}{2}\rho&#39; &lt; 0\)</span>， 那么 <span class="math inline">\(H(x)\)</span> 是非正定的。否则就可以调整残差和雅可比矩阵的权重。</p>
<h2 id="problem">Problem</h2>
<p><code>Problem</code>类实现了稳健的边界约束的非线性最小二乘问题，利用<code>Problem::AddResidualBlock()</code>和 <code>Problem::AddParameterBlock()</code>来创建最小二乘问题。 例如，一个包含三个大小分别为3,4,5的参数块和大小为2和6的残差块的问题： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">double x1[] &#x3D; &#123; 1.0, 2.0, 3.0 &#125;;</span><br><span class="line">double x2[] &#x3D; &#123; 1.0, 2.0, 3.0, 5.0 &#125;;</span><br><span class="line">double x3[] &#x3D; &#123; 1.0, 2.0, 3.0, 6.0, 7.0 &#125;;</span><br><span class="line"></span><br><span class="line">Problem problem;</span><br><span class="line">problem.AddResidualBlock(new MyUnaryCostFunction(...), x1);</span><br><span class="line">problem.AddResidualBlock(new MyBinaryCostFunction(...), x2, x3);</span><br></pre></td></tr></table></figure> <code>Problem::AddResidualBlock()</code>向最小二乘问题中添加一个残差块，它添加一个<code>CostFunction</code>， 一个可选的<code>LossFunction</code>，并连接<code>CostFunction</code>到参数块的集合中。<br />
代价函数带有它期望的参数块大小的信息，函数会检查那些与在<code>parameter block</code>列出的参数块大小 匹配的情况，如果检测到误匹配则程序终止。<code>loss_function</code>可为空，这样每一项的代价就只是残差的平方。</p>
<p>用户可以通过<code>Problem::AddParameterBlock()</code>来显式地添加参数块。这会引起额外的正确性检查； 但是<code>Problem::AddResidualBlock()</code>隐式地添加参数块（如果不存在的话），所以并不需要显式地 调用<code>Problem::AddParameterBlock()</code>。</p>
<p><code>Problem::AddResidualBlock()</code>显示得添加一个参数块到 <code>Problem</code> 中。用户可以选择将一个 <code>LocalParameterization</code> 和参数块相关联。重复调用相同的参数会被忽略。重复调用相同的double指针但用不同的大小会导致未定义行为。</p>
<p>使用<code>Problem::SetParameterBlockConstant()</code>可以设置任何参数块为常量，使用<code>Problem::SetParameterBlockVariable()</code>来取消。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/04/20/cpp-templates-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/20/cpp-templates-basic/" class="post-title-link" itemprop="url">cpp templates basic</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-20 14:29:45" itemprop="dateCreated datePublished" datetime="2019-04-20T14:29:45+00:00">2019-04-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="c模板基础">C++模板基础</h2>
<p>C++模板可以让我们写出类型无关的代码，极大地提高了代码的适用性，C++标准库的几乎所有代码都是模板代码。 ### 函数模板 函数模板可为不同的类型提供函数行为，其定义与普通函数类型，只不过类型是参数化的，以关键字<code>typename</code>开头，模板参数列表以逗号分开，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T max(T a,T b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T1,typename T2&gt;</span><br><span class="line">auto max(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 模板编译 用实际类型替换模板参数的过程称为实例化，结果是模板的一个实例。注意，仅仅使用函数模板就会触发实例化过程。尝试实例化一个不支持内部所有操作的类型将会导致编译期错误，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::complex&lt;float&gt; c1,c2; &#x2F;&#x2F; doesn&#39;t provide operator &lt;</span><br><span class="line">...</span><br><span class="line">::max(c1,c2); &#x2F;&#x2F; error at compile time</span><br></pre></td></tr></table></figure> 模板在两个阶段编译<br />
1. 在定义时没有实例化(<code>definition time</code>)，模板代码进行正确性检测，忽略模板参数，这个过程包括： - 句法错误，例如缺少分号 - 使用不依赖模板参数的未知的命名（类型名，函数名） - 不依赖模板参数的静态断言 2. 实例化时间(<code>instantiation time</code>),模板代码会再次进行检测确保所有代码是有效的，特别地，所有依赖模板参数的部分都会被重新检查<br />
事实上，一些编译器不会执行第一阶段的所有检查，所以一些错误直到第一次实例化时才会被发现。编译器在编译的时候需要看到模板的定义，这与普通函数的编译链接不同（函数声明对于编译就足够了）。处理这个问题的一个方法是将实现放在头文件中。 ### 模板参数推断 模板参数由我们传递的参数决定，如果传递两个<code>ints</code>到参数类型<code>T</code>。编译器就得出<code>T</code>一定是<code>int</code>类型。在类型推断的时候自动类型转换是有限制的： - 如果通过引用声明调用参数，不允许进行自动类型转换，每个类型T都必须正确地匹配 - 如果通过传值声明调用参数，<code>const</code> 或者<code>volatile</code>限定会被忽略，引用转换为引用的类型，原始数组或函数转换为相应的指针类型。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">T max(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">const int c &#x3D; 42;</span><br><span class="line">int i &#x3D; 10;</span><br><span class="line">max(i,c); &#x2F;&#x2F; T is deduced as int</span><br><span class="line">max(c,c); &#x2F;&#x2F; T is deduced as int</span><br><span class="line">int &amp;ir &#x3D; i;</span><br><span class="line">max(i,ir); &#x2F;&#x2F; T is deduced as int</span><br><span class="line">int arr[4];</span><br><span class="line">max(&amp;i,arr); &#x2F;&#x2F; T is deduced as int*</span><br></pre></td></tr></table></figure> ### 返回类型推断 最简单的方式是使用<code>auto</code>最为返回类型，但是要求实际返回类型能够从函数体内的声明推断。C++ 11可以使用关键字<code>decltype</code>， <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2&gt;</span><br><span class="line">auto max(T1 a, T2 b)-&gt; decltype(b&lt;a?a:b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 但是这种方式有一个缺点，当<code>T</code>是引用时，返回类型也是引用类型，这种情况下，应该返回<code>T</code>的退化类型，<code>auto</code>关键字初始化的类型始终是退化的。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">template&lt;typename T1,typename T2&gt;</span><br><span class="line">auto max(T1 a, T2 b) -&gt; typename</span><br><span class="line">std::decay&lt;decltype(true?a:b)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> C++11，标准库提供了<code>std::common_type&lt;&gt;::type</code>可以得到两个不同类型模板参数的公共类，注意，<code>std::common_type&lt;&gt;</code>也是退化的。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">template&lt;typename T1,typename T2&gt;</span><br><span class="line">std::common_type&lt;T1,T2&gt; max(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在内部实现，会根据操作符<code>?:</code>的语言规则和特定类型的特化来选择最终的类型，<code>::max(4,7.2)</code>和<code>::max(7.2,4)</code>得到的类型都是<code>double</code>。 ### 默认模板参数 你可以为模板参数定义默认值，例如，如果你想结合定义返回类型和具有多个参数类型的方法，你可以引入一个模板参数<code>RT</code>作为两个参数公共类型的返回类型。 1. 可以使用操作符<code>?:</code> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">template&lt;typename T1,typename T2,</span><br><span class="line">         typename RT &#x3D; std::decay_t&lt;decltype(true?T1():T2())&gt;&gt;</span><br><span class="line">RT max(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2. 使用<code>std::common_type&lt;&gt;</code>声明返回类型的默认值 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;type_traits&gt;</span><br><span class="line">template&lt;typename T1, typename T2,</span><br><span class="line">         typename RT &#x3D; std::common_type_t&lt;T1,T2&gt;&gt;</span><br><span class="line">RT max(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 作为调用者，你可以使用默认值作为返回类型或者显示声明返回类型 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto a &#x3D; ::max(4,7.2);</span><br><span class="line">auto b &#x3D; ::max&lt;double,int,long double&gt;(7.2,4);</span><br></pre></td></tr></table></figure> 但是，现在必须声明三个类型才能声明返回类型。相反，我们需要返回类型作为第一个模板参数，这也是可能的。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename RT &#x3D; long, typename T1, typename T2&gt;</span><br><span class="line">RT max(T1 a, T2 b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 重载函数模板 和普通函数一样，函数模板也可以重载，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; maximum of two int values:</span><br><span class="line">int max(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; maximum of  two values of any type:</span><br><span class="line">tempalte&lt;typename T&gt;</span><br><span class="line">T max(T a, T b)</span><br><span class="line">&#123;</span><br><span class="line">  return b &lt; a ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  ::max(7,42);&#x2F;&#x2F; calls the nontemplate for two ints</span><br><span class="line">  ::max(7.0,42.0); &#x2F;&#x2F; calls max&lt;double&gt;</span><br><span class="line">  ::max(&#39;a&#39;,&#39;b&#39;); &#x2F;&#x2F; calls max&lt;char&gt;</span><br><span class="line">  ::max&lt;&gt;(7,42); &#x2F;&#x2F; calls max&lt;int&gt;</span><br><span class="line">  ::max&lt;double&gt;(7,42); &#x2F;&#x2F; calls max&lt;double&gt;</span><br><span class="line">  ::max(&#39;a&#39;,42.7); &#x2F;&#x2F; calls the nontemplate for two ints</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 有相同名字的非模板函数和能实例化该类型的模板函数是可以共存的，非模板函数的优先级高于由模板函数推断的。但是如果模板可以产生一个更好的匹配，就会选择模板函数，也可以显示地说明使用模板。 ### 总结 - 函数模板为不同模板参数定义了一个函数家族 - 当你根据模板参数向函数参数传递变量对象时，函数模板会根据相应的参数类型实例化模板参数 - 你可以显示地声明模板参数 - 可以定义默认模板参数 - 可以重载函数模板，但需要确保对于任何调用只有一个匹配 - 在你调用之前确保编译器看到所有重载的函数模板版本。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/03/17/cpp-concurrency-managing-threads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/17/cpp-concurrency-managing-threads/" class="post-title-link" itemprop="url">【c++ concurrency】 线程管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-17 19:44:20" itemprop="dateCreated datePublished" datetime="2019-03-17T19:44:20+00:00">2019-03-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="线程管理基础">线程管理基础</h2>
<h3 id="启动线程">启动线程</h3>
<p>通过构造一个<code>std::thread</code>对象来开始一个线程，该对象声明运行在线程上的任务，最简单的是一个无参数返回值为空的普通函数，也可以是带有其他参数的函数对象，总之，<code>std::thread</code>对于任何可调用的类型都是有效的，例如，你可以传递一个带有函数调用操作符的类的实例给<code>std::thread</code>对象。但对于函数对象，如果传递的是一个临时的对象，线程对象的声明就与函数声明一样了，这时就需要用另外的括号或者用标准的初始化语法。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class backgroud_task</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">  void operator()() const</span><br><span class="line">  &#123;</span><br><span class="line">    do_something();</span><br><span class="line">    do_something_else();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">backgroud_task f;</span><br><span class="line">std::thread my_thread(f);</span><br><span class="line">std::thread my_thread1((backgroud_task())); &#x2F;&#x2F; right</span><br><span class="line">std::thread my_thread2&#123;backgroud_task()&#125;;  &#x2F;&#x2F; right</span><br></pre></td></tr></table></figure> lambda表达式可以避免这种情况，上边的例子可以写为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::thread my_thread([]&#123;do_something();</span><br><span class="line">  do_something_else();&#125;);</span><br></pre></td></tr></table></figure> ### 等待线程结束 如果希望等待一个线程完成，可以在相关的线程实例上调用<code>join()</code>函数，可以确保线程在函数退出，局部变量销毁之前线程结束。<code>jion()</code>是简单暴力的，要么等待线程结束要么不。<code>join()</code>会清理任何与线程相管理的储存，一旦调用<code>join</code>，<code>std::thread</code>对象就不再是可加入的了，<code>joinable()</code>将返回false。 你需要确保在<code>std::thread</code>对象销毁之前调用<code>join()</code>或者<code>detach()</code>，如果你想等待线程，就需要选择合适的地方调用<code>join()</code>。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">struct func</span><br><span class="line">&#123;</span><br><span class="line">  int&amp; i;</span><br><span class="line">  func(int&amp; i_):i(i_)&#123;&#125;</span><br><span class="line">  void operator()()</span><br><span class="line">  &#123;</span><br><span class="line">    for(unsigned j &#x3D;0; j &lt; 1000;++j)</span><br><span class="line">      do_something(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">  int some_local_state&#x3D;0;</span><br><span class="line">  func my_func(some_local_state);</span><br><span class="line">  std::thread t(my_func);</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    do_something_in_current_thread();</span><br><span class="line">  &#125;</span><br><span class="line">  catch(...)</span><br><span class="line">  &#123;</span><br><span class="line">    t.join();</span><br><span class="line">    throw;</span><br><span class="line">  &#125;</span><br><span class="line">  t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>try/catch</code>块确保获取局部状态的线程在函数有效之前结束，另外一种方法是使用RAII规则，提供一个类在其析构函数中调用<code>join()</code>，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class thread_guard</span><br><span class="line">&#123;</span><br><span class="line">  std::thread&amp; t;</span><br><span class="line">public:</span><br><span class="line">  explicit thread_guard(std::thread&amp; t_):</span><br><span class="line">    t(t_)&#123;&#125;</span><br><span class="line">  ~thread_guard()</span><br><span class="line">  &#123;</span><br><span class="line">    if(t.joinable())</span><br><span class="line">      t.join();</span><br><span class="line">  &#125;</span><br><span class="line">  thread_guard(thread_guard const&amp;)&#x3D;delete;</span><br><span class="line">  thread_guard&amp; operator&#x3D;(thread_guard const&amp;)&#x3D;delete;</span><br><span class="line">&#125;;</span><br><span class="line">struct func;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">  int some_local_state&#x3D;0;</span><br><span class="line">  func my_func(some_local_state);</span><br><span class="line">  std::thread t(my_func);</span><br><span class="line">  thread_guard g(t);</span><br><span class="line">  do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 在后台运行线程 在<code>std::thread</code>对象上调用<code>detach()</code>使线程在后台运行，这时没有直接的方法与其通信。等待线程结束不再是可能的，也不能获取线程对象的引用，也就不再可加入，所有权和控制转交给c++运行库 。在UNIX概念中称为守护线程(daemon thread)，运行在后台没有任何显示的用户接口。为了从一个<code>std::thread</code>对象分离线程，就必须有一个执行线程分离，只有<code>std::thread</code>对象<code>t</code>当<code>t.joinable()</code>返回<code>true</code>的时候，才可以调用<code>t.detach()</code>。 对于文字处理程序，当处理多个文档窗口时，可以使每个文档编辑窗口运行在其自己的线程中，线程管理请求并不关心等待其他线程结束，因为它在运行在一个不相关的文档上。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void edit_document(std::string const&amp; filename)</span><br><span class="line">&#123;</span><br><span class="line">  open_document_and_display_gui(filename);</span><br><span class="line">  while(!done_editing())</span><br><span class="line">  &#123;</span><br><span class="line">    user_command cmd &#x3D; get_user_input();</span><br><span class="line">    if(cmd.type &#x3D;&#x3D; open_new_document)</span><br><span class="line">    &#123;</span><br><span class="line">      std::string const new_name &#x3D; get_filename_from_use();</span><br><span class="line">      std::thread t(edit_document,new_name);</span><br><span class="line">      t.detach();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      process_user_input(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 向线程函数中传递参数 向<code>std::thread</code>构造函数传递额外的参数与向函数传参一样简单，要注意的是参数默认按拷贝方式复制到内部存储，执行的创建线程可以从这里获取参数。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void f(int i,std::string const&amp; s);</span><br><span class="line">std::thread t(f,3,&quot;hello&quot;);</span><br></pre></td></tr></table></figure> 当参数是指针的时候需要特别注意，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void f(int i,std::string const&amp; s);</span><br><span class="line">void oops(int some_param)</span><br><span class="line">&#123;</span><br><span class="line">  char buffer[1024];</span><br><span class="line">  sprintf(buffer,&quot;%i&quot;,some_param);</span><br><span class="line">  std::thread t(f,3,buffer);</span><br><span class="line">  t.detach();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这里，指向局部变量<code>buffer</code>的指针转递给一个新的线程，缓存在新线程中被转换为<code>std::string</code>之前，函数<code>oops</code>很有可能就退出了，将会导致未定义的行为，解决方法是在传递给线程构造函数前转换成<code>std::string</code>类型。 <code>std::thread t(f,3,std::string(buffer));</code> 另外一种情形是：对象被复制，你需要的则是引用，当一个线程更新按引用传递的数据结构时会出现这种情况，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void update_data_for_widget(widget_id w,widget_data&amp; data);</span><br><span class="line">void oops_again(widget_id w)</span><br><span class="line">&#123;</span><br><span class="line">  widget_data data;</span><br><span class="line">  std::thread t(update_data_for_widget,w,data);</span><br><span class="line">  display_status();</span><br><span class="line">  t.join();</span><br><span class="line">  process_widget_data(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 尽管<code>update_data_for_widget</code>函数期望第二个参数按引用传递，<code>std::thread</code>构造函数却不知道，最后传递给<code>update_data_for_widget</code>函数的时data的内部拷贝，而不是data本身的引用，因此传递给<code>process_widget_data</code>的时一个没有改变的data。解决方法是使用<code>std::ref</code>。 <code>std::thread t(update_data_for_widget,w,std::ref(data));</code> <code>std::thread</code>构造函数与<code>std::bind</code>工作机制相似，你可以传递一个成员函数指针作为函数，提供合适的对象指针作为第一个参数，例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class X</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line"> void do_lengthy_work();</span><br><span class="line">&#125;;</span><br><span class="line">X my_x;</span><br><span class="line">std::thread t(&amp;X::do_lengthy_work,&amp;my_x);</span><br></pre></td></tr></table></figure> 另外一种场景是参数不能被复制但是可以被移动(move)，这种类型的一个例子是<code>std::unique_ptr</code>，独占式指针，一个<code>std::unique_ptr</code>实例只能指向一个给定的对象一次，当实例销毁，指向的对象也被删除，可以利用<code>std::move</code>来转移一个动态对象的所有权到线程中。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void process_big_object(std::unique_ptr&lt;big_object&gt;);</span><br><span class="line">std::unique_ptr&lt;big_object&gt; p(new big_object);</span><br><span class="line">p-&gt;prepare_data(42);</span><br><span class="line">std::thread t(process_big_object,std::move(p));</span><br></pre></td></tr></table></figure> ## 转移线程所有权 尽管<code>std::thread</code>实例不像<code>std::unique_ptr</code>那样拥有动态对象，但它确实拥有资源：每个实例负责管理线程的执行，所有权可以在实例间进行转移，因为<code>std::thread</code>实例是<code>movable</code>，尽管它们不是<code>copyable</code>。这就确保了在任一时刻一个对象与特定的执行线程相关联，并允许开发人员在对象间转移所有权。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void some_function();</span><br><span class="line">void some_other_function();</span><br><span class="line">std::thread t1(some_function);</span><br><span class="line">std::thread t2&#x3D;std::move(t1);</span><br><span class="line">t1 &#x3D; std::thread(some_other_function);</span><br><span class="line">std::thread t3;</span><br><span class="line">t3 &#x3D; std::move(t2);</span><br><span class="line">t1 &#x3D; std::move(t3);</span><br></pre></td></tr></table></figure>  首先新线程t1创建，其所有权通过<code>std::move</code>转移到线程t2，这时t1不再有相关联的线程，运行<code>some_function</code>的线程为t2。然后一个新线程启动关联到一个临时<code>std::thread</code>对象，随后其所有权转移给t1，这并不需要调用<code>std::move()</code>，因为因为所有者是一个临时对象，<code>move</code>是自动隐式执行的。t3是默认构造的，并没有关联任何执行的线程，关联到t2的线程的所有权通过<code>std::move()</code>转移到t3，这是t1执行的是<code>some_other_function</code>，t2没有关联的线程，t3执行的是<code>some_function</code>。<br />
 最后运行<code>some_function</code>的线程的所有权转移回t1，但是这时t1已经关联了一个线程，所以<code>std::terminate()</code>被调用终止了程序。在线程析构之前，你必须显式地等待或者分离线程，不能通过向管理它的<code>std::thread</code>对象赋新值来丢弃一个线。<br />
 如果线程所有权要转移到一个函数中，函数只能以传值方式接受<code>std::thread</code>的实例作为参数。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void f(std::thread t);</span><br><span class="line">void g()</span><br><span class="line">&#123;</span><br><span class="line">  void some_function();</span><br><span class="line">  f(std::threads(some_function));</span><br><span class="line">  std::thread t(some_function);</span><br><span class="line">  f(std::move(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>std::thread</code>支持<code>move</code>操作可以使<code>thread_guard</code>类实际上获取线程所有权，这避免了<code>thread_guard</code>对象比它指向的线程生存时间长的问题，意味着一旦所有权转移到对象中，线程就不再可以被<code>join</code>或者<code>detach</code>。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class scoped_thread</span><br><span class="line">&#123;</span><br><span class="line">  std::thread t;</span><br><span class="line">public:</span><br><span class="line">  explicit scoped_thread(std::thread t_):</span><br><span class="line">    t(std::move(t_))</span><br><span class="line">  &#123;</span><br><span class="line">    if(!t.joinable())</span><br><span class="line">      throw std::logic_error(&quot;No thread&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  ~scoped_thread()</span><br><span class="line">  &#123;</span><br><span class="line">    t.join();</span><br><span class="line">  &#125;</span><br><span class="line">  scoped_thread(scoped_thread const&amp;)&#x3D;delete;</span><br><span class="line">  scoped_thread&amp; operator&#x3D;(scoped_thread const&amp;)&#x3D;delete;</span><br><span class="line">&#125;;</span><br><span class="line">struct func;</span><br><span class="line">void f()</span><br><span class="line">&#123;</span><br><span class="line">  int some_local_state;</span><br><span class="line">  scoped_thread t(std::thread(func(some_local_state)));</span><br><span class="line">  do_something_in_current_thread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>std::thread</code>支持<code>move</code>操作允许用容器存储线程对象。例如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void do_work(unsigned id);</span><br><span class="line">void if()</span><br><span class="line">&#123;</span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  for(unsigned i &#x3D; 0; i &lt; 20; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    threads.push_back(std::thread(do_work,i));</span><br><span class="line">  &#125;</span><br><span class="line">  std::for_each(threads.begin(),threads.end(),std::mem_fn(&amp;std::thread::join));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 选择线程个数及确认线程 <code>std::thread::hardware_concurrency()</code>返回执行程序真正并发运行时的线程个数。 通过<code>std::thread::id</code>类型来确认线程，线程对象调用<code>get_id()</code>成员函数来获取线程id，当前线程id可以通过调用<code>std::this_thread::get_id()</code>来获取。<code>std::thread::id</code>类型可以自由地复制和比较。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/01/29/dense-vo-approach-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/29/dense-vo-approach-overview/" class="post-title-link" itemprop="url">dense vo- direct method</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-29 10:11:04" itemprop="dateCreated datePublished" datetime="2019-01-29T10:11:04+00:00">2019-01-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础知识">基础知识</h2>
<h3 id="相机模型">相机模型</h3>
<p>相机模型描述了三维世界点到二维图像坐标点之间的映射，三维坐标到二维坐标的映射 <span class="math inline">\(\pi\)</span> 称为投影。表示为： <span class="math display">\[ \pi : {\mathbb R}^3 \rightarrow {\mathbb R}^3 \]</span> <img src="/2019/01/29/dense-vo-approach-overview/camera_model.png" class="" title="camera model"> 设2D图像点 <span class="math inline">\(x\)</span> 坐标为 <span class="math inline">\((x,y)\)</span>，对应的3D点为 <span class="math inline">\({\mathbf X}\)</span>，坐标为 <span class="math inline">\((X,Y,Z)\)</span>。有下列等式： <span class="math display">\[\begin{array}{c}
\pi(X,Y,Z)\rightarrow(x,y) \\
x = \frac{X \cdot f_x}{Z} + c_x \\
y = \frac{Y \cdot f_y}{Z} + c_y
\end{array}\]</span> 如果深度 <span class="math inline">\(Z\)</span> 和相机参数 <span class="math inline">\((f_x,f_y,c_x,c_y)\)</span> 已知，像素点 <span class="math inline">\(x\)</span> 对应的3D坐标为： <span class="math display">\[\begin{array}{c}
\pi^{-1}(x,y,Z) \rightarrow (X,Y,Z) \\
X = \frac{x-c_x}{f_x}Z \\
Y = \frac{y-c_y}{f_y}Z \\
Z = Z
\end{array}\]</span> ### 刚体变换 三维欧氏空间内的刚体变换保持向量的长度和夹角不发生变化，表示为： <span class="math display">\[g : {\mathbb R}^3 \rightarrow {\mathbb R}^3;  x \rightarrow g(x)\]</span> 设空间点 <span class="math inline">\(p\)</span> 的其次坐标为 <span class="math inline">\({(x,y,z,1)}^T\)</span>，经过变换后的空间点 <span class="math inline">\({p}&#39;= g(p) = ({x}&#39;,{y}&#39;,{z}&#39;,1)^T\)</span> <span class="math display">\[ g(p)= G\cdot p = \begin{pmatrix}
r_{11} &amp; r_{12} &amp; r_{13} &amp; t_x \\
r_{21} &amp; r_{22} &amp; r_{23} &amp; t_x \\
r_{31} &amp; r_{32} &amp; r_{33} &amp; t_x \\
0 &amp; 0 &amp; 0 &amp; 1 \end{pmatrix} \begin{pmatrix}
x \\ y \\ z \\ 1 \end{pmatrix}\]</span> 有：</p>
<p><span class="math display">\[\begin{array}{c}
{x}&#39; = r_{11}x + r_{12}y + r_{13}z + t_x \\
{y}&#39; = r_{21}x + r_{22}y + r_{23}z + t_y \\
{z}&#39; = r_{31}x + r_{32}y + r_{33}z + t_z
\end{array}\]</span></p>
<h3 id="李代数求导">李代数求导</h3>
<p>某空间点 <span class="math inline">\(p(x,y,z)\)</span> 经过一次变换 <span class="math inline">\(T\)</span> （对应李代数为 <span class="math inline">\(\xi\)</span>），得到 <span class="math inline">\({p}&#39; = Tp = ({x}&#39;,{y}&#39;,{z}&#39;)\)</span>。则变换后的点关于变换的导数为： <span class="math display">\[\begin{equation}\begin{aligned}\frac {\partial(Tp)}{\partial{\delta \xi}} &amp;= \begin{pmatrix} I &amp; -(Rp + t)^{\wedge} \end{pmatrix}  \\
&amp;= \begin{pmatrix}  1 &amp; 0 &amp; 0 &amp; 0 &amp; {z}&#39; &amp; -{y}&#39;\\
  0 &amp; 1 &amp; 0 &amp; -{z}&#39; &amp; 0 &amp; {x}&#39;\\
  0 &amp; 0 &amp; 1 &amp; {y}&#39; &amp; -{x}&#39; &amp; 0 \end{pmatrix}\end{aligned}\end{equation}\]</span> ## 直接法公式推导 ### 光度不变假设 <img src="/2019/01/29/dense-vo-approach-overview/photo_consistency.png" class="" title="photo-consistency"></p>
<p>点 <span class="math inline">\(p\)</span> 同时出现在图像 <span class="math inline">\(I_1\)</span> 和 <span class="math inline">\(I_2\)</span> 中，点 <span class="math inline">\(p\)</span> 投影在 <span class="math inline">\(I_1\)</span>上的像素坐标为 <span class="math inline">\(x\)</span>。给定一个相机的刚体变换 <span class="math inline">\(\xi\)</span>，变换方程 <span class="math inline">\(w(x)\)</span> 计算在 <span class="math inline">\(I_2\)</span>上的像素坐标，两者的灰度值应该一致，<span class="math inline">\(I_1(x) - I_2(w(x)) = 0\)</span>.<br />
最小化光度误差： <span class="math display">\[\xi^* = arg min(I_2(w(\xi,x)) - I_1(x))^2\]</span> 变换函数 <span class="math inline">\(w(\xi,x)\)</span> 定义为： <span class="math display">\[w(\xi,x) = \pi(g(G(\xi),\pi^{-1}(x,Z_1(x))))\]</span></p>
<h3 id="线性化">线性化</h3>
<p>存在多种等价的线性化方法，这里介绍两种，第一种每次迭代时在上次估计的附近线性化，称为Forward Additive Algorithm。第二种在一个固定的点附近线性展开，在每次迭代后只需用上次估计的变换更新输入图像，只需在初始的点附近线性化，节省了计算代价，点的雅可比矩阵是固定的，称为Forward Compositional Algorithm</p>
<h4 id="forward-additive-algorithm">Forward Additive Algorithm</h4>
<p>位姿参数增量 <span class="math inline">\(\Delta \xi\)</span> 连接到上一次的估计。<span class="math inline">\(\xi_{k+1} = \log(\exp(\xi_k) \cdot \exp(\Delta\xi)) = \xi_k\oplus \Delta\xi\)</span><br />
误差方程为： <span class="math display">\[r_i(\xi_{k+1}) = I_2(w(\xi_k\oplus \Delta\xi,x_i)) - I_1(x_i)\]</span> 线性化： <span class="math display">\[r_{lin,i}(\xi_{k+1}) = r_i(\xi_k) + J_i(\xi_k)\Delta\xi\]</span> 残差 <span class="math inline">\(r_i(\xi_k)\)</span> 为： <span class="math display">\[r_i(\xi_k) = I_2(w(\xi_k,x_i)) - I_1(x_i)\]</span> 根据链式法则，雅可比矩阵 <span class="math inline">\(J_i(\xi_k)\)</span> 可分解为： <span class="math display">\[J_i(\xi_k) = J_IJ_w = J_IJ_{\pi}J_gJ_G\]</span><br />
其中， <span class="math inline">\(J_I\)</span>为像素在 x , y 方向的梯度， <span class="math inline">\(J_{\pi}\)</span> 为投影方程关与变换后的三维点的导数， <span class="math inline">\(J_gJ_G\)</span> 为变换后的三维点关于变换 <span class="math inline">\(\xi\)</span> 的导数。</p>
<p><span class="math inline">\(p_i = (x,y,z)^T=\pi^{-1}(x_i,Z_1(x_i))\)</span>，<span class="math inline">\({x}&#39;,{y}&#39;,{z}&#39;\)</span> 为 <span class="math inline">\(p_i\)</span> 转换后的3D坐标。 <span class="math display">\[J_I = \begin{pmatrix}\Delta I_{2,x} &amp; \Delta I_{2,y}\end{pmatrix}\]</span></p>
<p><span class="math display">\[J_{\pi} = \begin{pmatrix}
  f_x\frac 1{z&#39;} &amp; 0 &amp; -f_x\frac { x&#39;}{ z&#39;^2} \\
  0 &amp; f_y\frac 1{z&#39;} &amp; -f_y\frac {y&#39;}{z&#39;^2} \end{pmatrix}\]</span></p>
<p><span class="math display">\[J_gJ_G = \begin{pmatrix}
  1 &amp; 0 &amp; 0 &amp; 0 &amp; {z}&#39; &amp; -{y}&#39;\\
  0 &amp; 1 &amp; 0 &amp; -{z}&#39; &amp; 0 &amp; {x}&#39;\\
  0 &amp; 0 &amp; 1 &amp; {y}&#39; &amp; -{x}&#39; &amp; 0 \end{pmatrix}\]</span></p>
<p>因此： <span class="math display">\[J_IJ_w = \begin{pmatrix}\Delta I_{2,x} &amp; \Delta I_{2,y}\end{pmatrix} \begin{pmatrix}
  f_x\frac1{z&#39;} &amp; 0 &amp;-f_x\frac{x&#39;}{z&#39;^2} &amp; -f_x\frac{x&#39;y&#39;}{z&#39;^2} &amp; f_x(1 + \frac{x&#39;^2}{z&#39;^2}) &amp; -f_x\frac{y&#39;}{z&#39;} \\
  0 &amp; f_y\frac1{z&#39;} &amp; -f_y\frac{y&#39;}{z&#39;^2} &amp; -f_y(1+\frac{y&#39;^2}{z&#39;^2}) &amp; f_y\frac{x&#39;y&#39;}{z&#39;^2} &amp; f_y\frac{x&#39;}{z&#39;}
   \end{pmatrix}\]</span><br />
雅可比矩阵 <span class="math inline">\(J_w\)</span>在每次迭代过程中都会改变，因为由深度图 <span class="math inline">\(Z_1\)</span> 得到的点 <span class="math inline">\(p_i\)</span> 都要经过上一次估计 <span class="math inline">\(\xi\)</span> 变换。 #### Forward Compositional Algorithm 与Forward Additive Algorithm不同，Forward Compositional是针对变换后的像素坐标而不是估计位姿。 误差方程为： <span class="math display">\[r_i(\xi_{k+1}) = I_2(w(\xi_k,w(\Delta\xi,x_i))) - I_1(x_i)\]</span> 线性化： <span class="math display">\[r_{lin,i}(\xi_{k+1}) = r_i(0) + J_i(0)\Delta\xi\]</span> 残差 <span class="math inline">\(r_i(\xi_k)\)</span> 为： <span class="math display">\[r_i(0) = I_2(w(\xi_k,x_i)) - I_1(x_i)\]</span> 根据链式法则，雅可比矩阵 <span class="math inline">\(J_i(\xi_k)\)</span> 可分解为： <span class="math display">\[J_i(0) = J_IJ_w = J_IJ_{\pi}J_gJ_G\]</span> 在 <span class="math inline">\(\Delta\xi = 0\)</span> 附近线性化，简化了三维点的雅可比矩阵，因为 <span class="math inline">\(G(0)\)</span> 为单位阵，因此在每次迭代过程中三维点的雅可比矩阵是不变的。因此各雅可比矩阵的定义为： <span class="math display">\[ J_I = \begin{pmatrix}\Delta I_{2,x} &amp; \Delta I_{2,y}\end{pmatrix}\]</span> <span class="math display">\[J_{\pi} = \begin{pmatrix}
f_x\frac 1z &amp; 0 &amp; -f_x\frac x{z^2} \\
0 &amp; f_y\frac 1z &amp; -f_y\frac y{z^2} \end{pmatrix}\]</span> <span class="math display">\[J_gJ_G = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; z &amp; -y\\
0 &amp; 1 &amp; 0 &amp; -z &amp; 0 &amp; x\\
0 &amp; 0 &amp; 1 &amp; y &amp; -x &amp; 0 \end{pmatrix}\]</span> 因此： <span class="math display">\[J_IJ_w = \begin{pmatrix}\Delta I_{2,x} &amp; \Delta I_{2,y}\end{pmatrix} \begin{pmatrix}
f_x\frac 1z &amp; 0 &amp;-f_x\frac x{z^2} &amp; -f_x\frac {xy}{z^2} &amp; f_x(1 + \frac {x^2}{z^2}) &amp; -f_x\frac yz \\
0 &amp; f_y\frac 1z &amp; -f_y\frac y{z^2} &amp; -f_y(1+\frac {y^2}{z^2}) &amp; f_y\frac{xy}{z^2}  &amp; f_y\frac xy
 \end{pmatrix}\]</span><br />
在计算得到雅可比矩阵后，就可以在每次迭代过程中通过求解法方程得到位姿增量： <span class="math display">\[ J^TJ\delta_{\xi}=J^T\epsilon\]</span> <span class="math inline">\(\delta_{\xi}\)</span> 为位姿增量， <span class="math inline">\(\epsilon\)</span> 为光度残差 ## 光度误差+几何误差 类似光度误差，对于深度图可以定义几何误差 最小化几何误差： <span class="math display">\[\xi^* = arg min(D_2(w(\xi,x)) - D_1(x))^2\]</span> 这里的雅可比矩阵为： <span class="math display">\[J_i(0) = J_DJ_W - J_z\]</span> 其中 <span class="math inline">\(J_D\)</span> 为深度图 x, y 方向的梯度， <span class="math inline">\(J_W\)</span> 为误差方程关于变换的导数与光度误差的 <span class="math inline">\(J_W\)</span>一致， <span class="math inline">\(J_z\)</span> 为深度值(z)关于变换的导数，因此为三维点关于变换的雅可比矩阵的第三行。这里的几何误差类似与ICP的误差项。 ## 代码实现 dvo_slam实现的是光度误差+深度误差的Dense VO <a target="_blank" rel="noopener" href="https://github.com/tum-vision/dvo_slam">https://github.com/tum-vision/dvo_slam</a> ## 参考文献 [1] 高翔.等.视觉SLAM十四讲[M].中国工信出版集团<br />
[2] Odometry from RGB-D Cameras for Autonomous Quadrocopters (C. Kerl), Master's thesis, Technical University Munich, 2012.<br />
[3] Robust Odometry Estimation for RGB-D Cameras (C. Kerl, J. Sturm, D. Cremers), In International Conference on Robotics and Automation (ICRA), 2013.<br />
[4] Dense Visual SLAM for RGB-D Cameras (C. Kerl, J. Sturm, D. Cremers), In Proc. of the Int. Conf. on Intelligent Robot Systems (IROS), 2013.<br />
[5] Dense Continuous-Time Tracking and Mapping with Rolling Shutter RGB-D Cameras (C. Kerl, J. Stueckler, D. Cremers), In IEEE International Conference on Computer Vision (ICCV), 2015.</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/01/05/linear-least-squares-optimization-for-point-to-plane-icp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog-logo.jpg">
      <meta itemprop="name" content="Meng Zhili">
      <meta itemprop="description" content="focus creates reality">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Meng's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/05/linear-least-squares-optimization-for-point-to-plane-icp/" class="post-title-link" itemprop="url">Linear point-to-plane ICP method</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-05 22:32:55" itemprop="dateCreated datePublished" datetime="2019-01-05T22:32:55+00:00">2019-01-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-10-01 19:49:30" itemprop="dateModified" datetime="2021-10-01T19:49:30+00:00">2021-10-01</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/SLAM/" itemprop="url" rel="index"><span itemprop="name">SLAM</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="摘要">摘要</h2>
<p>ICP算法中选择点到平面的误差度量比点到点的误差度量要收敛得更快，在ICP算法得每次迭代中最小化点到平面误差通常是一个标准非线性最小二乘问题，求解通常非常慢，但两帧点云之间的旋转角度较小时，可以近似为线性最小二乘问题。</p>
<h2 id="算法原理及公式推导">算法原理及公式推导</h2>
<p>给定一个source点云和target点云，ICP算法在每次迭代中估计source点云和target点云之间的一致性点对集合，估计误差最小时的4x4刚体变换矩阵 <span class="math inline">\(\mathbf M\)</span>，当使用点到平面的误差度量时，最小化的目标是每个源点和它对应目标点所在平面距离的平方和。设源点为 <span class="math inline">\(\mathbf s_i = {(s_{ix},s_{iy},s_{iz},1)}^T\)</span>，对应的目标点为 <span class="math inline">\(\mathbf d_i = {(d_{ix},d_{iy},d_{iz},1)}^T\)</span>，<span class="math inline">\(\mathbf n_i = {(n_{ix},n_{iy},n_{iz},0)}^T\)</span> 是 <span class="math inline">\(\mathbf d_i\)</span>处的单位法向量，ICP每次迭代的目标是找到一个最佳的 <span class="math inline">\(\mathbf M_{opt}\)</span> 使： <span class="math display">\[\mathbf M_{opt} = argmin\sum_i{((M\cdot s_i - d_i)\cdot n_i)}^2  (1)\]</span><br />
<img src="/2019/01/05/linear-least-squares-optimization-for-point-to-plane-icp/point-to-plane-error.png" class="" title="point2plane"> 刚体变换矩阵 <span class="math inline">\(\mathbf M\)</span>由一个旋转矩阵 <span class="math inline">\(\mathbf R(\alpha ,\beta,\gamma)\)</span> 和平移矩阵 <span class="math inline">\(\mathbf T(t_x,t_y,t_z)\)</span> 组成。 <span class="math display">\[ \mathbf M = \mathbf R(\alpha ,\beta,\gamma)\cdot \mathbf T(t_x,t_y,t_z)\]</span> 其中 <span class="math display">\[\mathbf T(t_x,t_y,t_z) = \begin{pmatrix}
1 &amp; 0 &amp; 0 &amp; t_x \\
0 &amp; 1 &amp; 0 &amp; t_y \\
0 &amp; 0 &amp; 1 &amp; t_z \\
0 &amp; 0 &amp; 0 &amp; 1 \\ \end{pmatrix}\]</span></p>
<p><span class="math display">\[\mathbf R(\alpha,\beta,\gamma) = \begin{pmatrix}
r_{11} &amp; r_{12} &amp; r_{13} &amp; 0 \\
r_{21} &amp; r_{22} &amp; r_{23} &amp; 0 \\
r_{31} &amp; r_{32} &amp; r_{33} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\ \end{pmatrix}\]</span> 这里： <span class="math inline">\(\alpha\)</span>，<span class="math inline">\(\beta\)</span>，<span class="math inline">\(\gamma\)</span> 分别为x轴，y轴和z轴的旋转角度。 <span class="math display">\[
\begin{aligned}
r_{11} &amp;=\cos\gamma \cos\beta, \\
r_{12} &amp;=-\sin\gamma \cos\alpha + \cos\gamma\sin\beta\sin\alpha, \\
r_{13} &amp;=\sin\gamma\sin\alpha + \cos\gamma\sin\beta\sin\alpha, \\
r_{21} &amp;=\sin\gamma\cos\beta, \\
r_{22} &amp;=\cos\gamma\cos\alpha + \sin\gamma\sin\beta\sin\alpha, \\
r_{23} &amp;=-\cos\gamma\sin\alpha + \sin\gamma\sin\beta\cos\alpha, \\
r_{31} &amp;= -\sin\beta, \\
r_{32} &amp;= \cos\beta\sin\alpha, \\
r_{33} &amp;= \cos\beta\cos\alpha. \\
\end{aligned}
\]</span> ### 线性化 当角度 <span class="math inline">\(\theta \approx 0\)</span>时，得到 <span class="math inline">\(\sin\theta \approx \theta\)</span> 和 <span class="math inline">\(\cos\theta \approx 1\)</span>，因此，当 <span class="math inline">\(\alpha,\beta,\gamma \approx 0\)</span>时， <span class="math display">\[\mathbf R(\alpha,\beta,\gamma) \approx
 \begin{pmatrix}
1 &amp; \alpha\beta - \gamma &amp; \alpha\gamma + \beta &amp; 0 \\
\gamma &amp; \alpha\beta\gamma + 1 &amp; \beta\gamma - \alpha &amp; 0 \\
-\beta &amp; \alpha &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix} \approx
\begin{pmatrix}
1 &amp; -\gamma &amp; \beta &amp; 0 \\
\gamma &amp; 1 &amp; -\alpha &amp; 0 \\
-\beta &amp; \alpha &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix}
\]</span> 变换矩阵 <span class="math inline">\(\mathbf M\)</span> 近似为 <span class="math display">\[\mathbf{\hat M} = \mathbf T(t_x,t_y,t_z) \cdot \mathbf{\hat R}(\alpha,\beta,\gamma) \\ =
\begin{pmatrix}
1 &amp; -\gamma &amp; \beta &amp; t_x \\
\gamma &amp; 1 &amp; -\alpha &amp; t_y \\
-\beta &amp; \alpha &amp; 1 &amp; t_z \\
0 &amp; 0 &amp; 0 &amp; 1 \\
\end{pmatrix}\]</span> 最小化目标方程可以重写为： <span class="math display">\[\mathbf {\hat M_{opt}} = argmin\sum_i{((\mathbf {\hat M}\cdot s_i - d_i)\cdot n_i)}^2\]</span> <span class="math inline">\((\mathbf {\hat M}\cdot s_i - d_i)\cdot n_i\)</span> 可以写为六个参数 <span class="math inline">\(\alpha\)</span>，<span class="math inline">\(\beta\)</span>，<span class="math inline">\(\gamma\)</span>，<span class="math inline">\(t_x\)</span>，<span class="math inline">\(t_y\)</span> 和 <span class="math inline">\(t_z\)</span>的线性表达式： <span class="math display">\[(\mathbf {\hat M}\cdot s_i - d_i)\cdot n_i =
  \left(\mathbf {\hat M} \cdot
  \begin{pmatrix}
  s_{ix} \\ s_{iy} \\ s_{iz} \\ 1 \\
  \end{pmatrix} - \begin{pmatrix}d_{ix} \\ d_{iy} \\ d_{iz} \\ 1 \\ \end{pmatrix}
  \right) \cdot \begin{pmatrix}n_{ix} \\ n_{iy} \\ n_{iz} \\ 0 \\ \end{pmatrix} \\
  = [(n_{iz}s_{iy}-n_{iy}s_{iz})\alpha + (n_{ix}s_{iz} - n_{iz}s_{ix})\beta + (n_{iy}s_{ix} - n_{ix}s_{iy})\gamma \\ + n_{ix}t_x + n_{iy}t_y + n_{iz}t_z] - \\ [n_{ix}d_{ix} + n_{iy}d_{iy}+n_{iz}d_{iz} - n_{ix}s_{ix} - n_{iy}s_{iy} - n_{iz}s_{iz}]
  \]</span> 给出N对一致性点，可将表达式写成矩阵的形式： <span class="math display">\[\mathbf{Ax - b}\]</span> 这里： <span class="math display">\[\mathbf b = \begin{pmatrix}
n_{1x}d_{1x} + n_{1y}d_{1y} + n_{1z}d_{1z} - n_{1x}s_{1x} - n_{1y}s_{1y} - n_{1z}s_{1z} \\
n_{2x}d_{2x} + n_{2y}d_{2y} + n_{2z}d_{2z} - n_{2x}s_{2x} - n_{2y}s_{2y} - n_{2z}s_{2z} \\
\vdots \\
n_{Nx}d_{Nx} + n_{Ny}d_{Ny} + n_{Nz}d_{Nz} - n_{Nx}s_{Nx} - n_{Ny}s_{Ny} - n_{Nz}s_{Nz} \\
 \end{pmatrix}\]</span></p>
<p><span class="math display">\[\mathbf x = {(\alpha \quad \beta \quad \gamma \quad t_x \quad t_y \quad t_z)}^T\]</span></p>
<p><span class="math display">\[\mathbf A = \begin{pmatrix}
 a_{11} &amp; a_{12} &amp; a_{13} &amp; n_{1x} &amp; n_{1y} &amp; n_{1z} \\
 a_{21} &amp; a_{22} &amp; a_{23} &amp; n_{2x} &amp; n_{2y} &amp; n_{2z} \\
 \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
  a_{N1} &amp; a_{N2} &amp; a_{N3} &amp; n_{Nx} &amp; n_{Ny} &amp; n_{Nz} \\
\end{pmatrix}\]</span> 这里： <span class="math display">\[
\begin{array}{c}
a_{i1} = n_{iz}s{iy} - n_{iy}s_{iz} \\
a_{i2} = n_{ix}s{iz} - n_{iz}s_{ix} \\
a_{i3} = n_{iy}s{ix} - n_{ix}s_{iy}
\end{array}
\]</span> 因此： <span class="math display">\[min\sum_i{((\mathbf {\hat M}\cdot s_i - d_i)\cdot n_i)}^2 = min{|\mathbf{Ax-b}|}^2\]</span> 通过解方程 <span class="math inline">\(\mathbf{Ax=b}\)</span> 可以求得最佳的变换矩阵 <span class="math inline">\(\mathbf {\hat M_{opt}}\)</span> ## 代码实现 pcl配准模块实现了point to plane lls，参考transformation_estimation_point_to_plane_lls.hpp ，在实际实现时，为了提高计算的数值稳定性通常先将点云归一化，再进行配准。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">Matrix6d ATA;</span><br><span class="line">Vector6d ATb;</span><br><span class="line">ATA.setZero ();</span><br><span class="line">ATb.setZero ();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Approximate as a linear least squares problem</span><br><span class="line">while (source_it.isValid () &amp;&amp; target_it.isValid ())</span><br><span class="line">&#123;</span><br><span class="line">  if (!pcl_isfinite (source_it-&gt;x) ||</span><br><span class="line">      !pcl_isfinite (source_it-&gt;y) ||</span><br><span class="line">      !pcl_isfinite (source_it-&gt;z) ||</span><br><span class="line">      !pcl_isfinite (target_it-&gt;x) ||</span><br><span class="line">      !pcl_isfinite (target_it-&gt;y) ||</span><br><span class="line">      !pcl_isfinite (target_it-&gt;z) ||</span><br><span class="line">      !pcl_isfinite (target_it-&gt;normal_x) ||</span><br><span class="line">      !pcl_isfinite (target_it-&gt;normal_y) ||</span><br><span class="line">      !pcl_isfinite (target_it-&gt;normal_z))</span><br><span class="line">  &#123;</span><br><span class="line">    ++target_it;</span><br><span class="line">    ++source_it;    </span><br><span class="line">    continue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const float &amp; sx &#x3D; source_it-&gt;x;</span><br><span class="line">  const float &amp; sy &#x3D; source_it-&gt;y;</span><br><span class="line">  const float &amp; sz &#x3D; source_it-&gt;z;</span><br><span class="line">  const float &amp; dx &#x3D; target_it-&gt;x;</span><br><span class="line">  const float &amp; dy &#x3D; target_it-&gt;y;</span><br><span class="line">  const float &amp; dz &#x3D; target_it-&gt;z;</span><br><span class="line">  const float &amp; nx &#x3D; target_it-&gt;normal[0];</span><br><span class="line">  const float &amp; ny &#x3D; target_it-&gt;normal[1];</span><br><span class="line">  const float &amp; nz &#x3D; target_it-&gt;normal[2];</span><br><span class="line"></span><br><span class="line">  double a &#x3D; nz*sy - ny*sz;</span><br><span class="line">  double b &#x3D; nx*sz - nz*sx;</span><br><span class="line">  double c &#x3D; ny*sx - nx*sy;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;    0  1  2  3  4  5</span><br><span class="line">  &#x2F;&#x2F;    6  7  8  9 10 11</span><br><span class="line">  &#x2F;&#x2F;   12 13 14 15 16 17</span><br><span class="line">  &#x2F;&#x2F;   18 19 20 21 22 23</span><br><span class="line">  &#x2F;&#x2F;   24 25 26 27 28 29</span><br><span class="line">  &#x2F;&#x2F;   30 31 32 33 34 35</span><br><span class="line"></span><br><span class="line">  ATA.coeffRef (0) +&#x3D; a * a;</span><br><span class="line">  ATA.coeffRef (1) +&#x3D; a * b;</span><br><span class="line">  ATA.coeffRef (2) +&#x3D; a * c;</span><br><span class="line">  ATA.coeffRef (3) +&#x3D; a * nx;</span><br><span class="line">  ATA.coeffRef (4) +&#x3D; a * ny;</span><br><span class="line">  ATA.coeffRef (5) +&#x3D; a * nz;</span><br><span class="line">  ATA.coeffRef (7) +&#x3D; b * b;</span><br><span class="line">  ATA.coeffRef (8) +&#x3D; b * c;</span><br><span class="line">  ATA.coeffRef (9) +&#x3D; b * nx;</span><br><span class="line">  ATA.coeffRef (10) +&#x3D; b * ny;</span><br><span class="line">  ATA.coeffRef (11) +&#x3D; b * nz;</span><br><span class="line">  ATA.coeffRef (14) +&#x3D; c * c;</span><br><span class="line">  ATA.coeffRef (15) +&#x3D; c * nx;</span><br><span class="line">  ATA.coeffRef (16) +&#x3D; c * ny;</span><br><span class="line">  ATA.coeffRef (17) +&#x3D; c * nz;</span><br><span class="line">  ATA.coeffRef (21) +&#x3D; nx * nx;</span><br><span class="line">  ATA.coeffRef (22) +&#x3D; nx * ny;</span><br><span class="line">  ATA.coeffRef (23) +&#x3D; nx * nz;</span><br><span class="line">  ATA.coeffRef (28) +&#x3D; ny * ny;</span><br><span class="line">  ATA.coeffRef (29) +&#x3D; ny * nz;</span><br><span class="line">  ATA.coeffRef (35) +&#x3D; nz * nz;</span><br><span class="line"></span><br><span class="line">  double d &#x3D; nx*dx + ny*dy + nz*dz - nx*sx - ny*sy - nz*sz;</span><br><span class="line">  ATb.coeffRef (0) +&#x3D; a * d;</span><br><span class="line">  ATb.coeffRef (1) +&#x3D; b * d;</span><br><span class="line">  ATb.coeffRef (2) +&#x3D; c * d;</span><br><span class="line">  ATb.coeffRef (3) +&#x3D; nx * d;</span><br><span class="line">  ATb.coeffRef (4) +&#x3D; ny * d;</span><br><span class="line">  ATb.coeffRef (5) +&#x3D; nz * d;</span><br><span class="line"></span><br><span class="line">  ++target_it;</span><br><span class="line">  ++source_it;    </span><br><span class="line">&#125;</span><br><span class="line">ATA.coeffRef (6) &#x3D; ATA.coeff (1);</span><br><span class="line">ATA.coeffRef (12) &#x3D; ATA.coeff (2);</span><br><span class="line">ATA.coeffRef (13) &#x3D; ATA.coeff (8);</span><br><span class="line">ATA.coeffRef (18) &#x3D; ATA.coeff (3);</span><br><span class="line">ATA.coeffRef (19) &#x3D; ATA.coeff (9);</span><br><span class="line">ATA.coeffRef (20) &#x3D; ATA.coeff (15);</span><br><span class="line">ATA.coeffRef (24) &#x3D; ATA.coeff (4);</span><br><span class="line">ATA.coeffRef (25) &#x3D; ATA.coeff (10);</span><br><span class="line">ATA.coeffRef (26) &#x3D; ATA.coeff (16);</span><br><span class="line">ATA.coeffRef (27) &#x3D; ATA.coeff (22);</span><br><span class="line">ATA.coeffRef (30) &#x3D; ATA.coeff (5);</span><br><span class="line">ATA.coeffRef (31) &#x3D; ATA.coeff (11);</span><br><span class="line">ATA.coeffRef (32) &#x3D; ATA.coeff (17);</span><br><span class="line">ATA.coeffRef (33) &#x3D; ATA.coeff (23);</span><br><span class="line">ATA.coeffRef (34) &#x3D; ATA.coeff (29);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Solve A*x &#x3D; b</span><br><span class="line">Vector6d x &#x3D; static_cast&lt;Vector6d&gt; (ATA.inverse () * ATb);</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>


<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Meng Zhili</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
